# Readdy Editor æ‰©å±•å¼€å‘æŒ‡å—

## ğŸ“‹ æ¦‚è¿°

æœ¬æŒ‡å—è¯¦ç»†è¯´æ˜å¦‚ä½•æ‰©å±• Readdy Editor çš„åŠŸèƒ½ï¼ŒåŒ…æ‹¬æ”¯æŒæ–°çš„æ–‡ä»¶ç±»å‹ã€ç¼–è¾‘å™¨åŠŸèƒ½ã€AIæ¨¡å‹é›†æˆã€UIç»„ä»¶ç­‰ã€‚é€šè¿‡æ¨¡å—åŒ–çš„æ¶æ„è®¾è®¡ï¼Œå¼€å‘è€…å¯ä»¥è½»æ¾åœ°ä¸ºç¼–è¾‘å™¨æ·»åŠ æ–°åŠŸèƒ½è€Œä¸å½±å“ç°æœ‰ç³»ç»Ÿã€‚

## ğŸ—ï¸ æ‰©å±•æ¶æ„æ¦‚è§ˆ

### æ‰©å±•ç‚¹åˆ†ç±»
```
Readdy Editor æ‰©å±•ç³»ç»Ÿ
â”œâ”€â”€ æ–‡ä»¶ç±»å‹æ‰©å±•
â”‚   â”œâ”€â”€ è¯­æ³•é«˜äº®æ”¯æŒ
â”‚   â”œâ”€â”€ æ–‡ä»¶å›¾æ ‡å®šåˆ¶
â”‚   â”œâ”€â”€ è¯­è¨€æœåŠ¡é›†æˆ
â”‚   â””â”€â”€ è‡ªå®šä¹‰æ¸²æŸ“å™¨
â”œâ”€â”€ ç¼–è¾‘å™¨åŠŸèƒ½æ‰©å±•
â”‚   â”œâ”€â”€ ç¼–è¾‘å™¨æ’ä»¶
â”‚   â”œâ”€â”€ å¿«æ·é”®ç»‘å®š
â”‚   â”œâ”€â”€ ä¸»é¢˜æ‰©å±•
â”‚   â””â”€â”€ å·¥å…·æ å®šåˆ¶
â”œâ”€â”€ AIæœåŠ¡æ‰©å±•
â”‚   â”œâ”€â”€ æ–°AIæä¾›å•†
â”‚   â”œâ”€â”€ è‡ªå®šä¹‰æç¤ºè¯
â”‚   â”œâ”€â”€ ä¸“ä¸šåŒ–AIåŠ©æ‰‹
â”‚   â””â”€â”€ AIå·¥ä½œæµ
â”œâ”€â”€ UI/UXæ‰©å±•
â”‚   â”œâ”€â”€ æ–°ç»„ä»¶å¼€å‘
â”‚   â”œâ”€â”€ å¸ƒå±€æ¨¡å¼
â”‚   â”œâ”€â”€ äº¤äº’å¢å¼º
â”‚   â””â”€â”€ å¯è®¿é—®æ€§
â””â”€â”€ é›†æˆæ‰©å±•
    â”œâ”€â”€ å¤–éƒ¨å·¥å…·é›†æˆ
    â”œâ”€â”€ APIæ¥å£
    â”œâ”€â”€ æ’ä»¶ç³»ç»Ÿ
    â””â”€â”€ æ•°æ®å¯¼å…¥å¯¼å‡º
```

## ğŸ“ æ–‡ä»¶ç±»å‹æ‰©å±•

### 1. åŸºç¡€æ–‡ä»¶ç±»å‹æ”¯æŒ

#### æ·»åŠ æ–°çš„æ–‡ä»¶ç±»å‹è¯†åˆ«
```typescript
// types/file-types.ts
export interface FileTypeDefinition {
  extension: string[]           // æ–‡ä»¶æ‰©å±•å
  name: string                 // æ˜¾ç¤ºåç§°
  category: 'code' | 'markup' | 'data' | 'image' | 'document'
  icon: string                 // å›¾æ ‡ç±»å
  monacoLanguage?: string      // Monacoè¯­è¨€ID
  defaultContent?: string      // é»˜è®¤å†…å®¹æ¨¡æ¿
  customRenderer?: boolean     // æ˜¯å¦éœ€è¦è‡ªå®šä¹‰æ¸²æŸ“å™¨
}

// å†…ç½®æ–‡ä»¶ç±»å‹å®šä¹‰
export const FILE_TYPES: Record<string, FileTypeDefinition> = {
  markdown: {
    extension: ['md', 'markdown'],
    name: 'Markdown',
    category: 'markup',
    icon: 'ri-markdown-fill',
    monacoLanguage: 'markdown',
    defaultContent: '# æ–°å»ºæ–‡æ¡£\n\nå¼€å§‹ç¼–å†™å†…å®¹...'
  },
  
  javascript: {
    extension: ['js', 'jsx'],
    name: 'JavaScript',
    category: 'code',
    icon: 'ri-javascript-fill',
    monacoLanguage: 'javascript',
    defaultContent: '// JavaScript æ–‡ä»¶\nconsole.log("Hello World");'
  },

  python: {
    extension: ['py'],
    name: 'Python',
    category: 'code',
    icon: 'ri-code-s-slash-fill',
    monacoLanguage: 'python',
    defaultContent: '# Python æ–‡ä»¶\nprint("Hello World")'
  },

  // æ–°å¢ï¼šæ”¯æŒæ›´å¤šç±»å‹
  rust: {
    extension: ['rs'],
    name: 'Rust',
    category: 'code',
    icon: 'ri-terminal-box-fill',
    monacoLanguage: 'rust',
    defaultContent: 'fn main() {\n    println!("Hello, world!");\n}'
  },

  vue: {
    extension: ['vue'],
    name: 'Vue Component',
    category: 'code',
    icon: 'ri-vuejs-fill',
    monacoLanguage: 'html',
    defaultContent: `<template>
  <div>
    <h1>{{ title }}</h1>
  </div>
</template>

<script setup lang="ts">
import { ref } from 'vue'

const title = ref('Vue Component')
</script>

<style scoped>
h1 {
  color: #42b883;
}
</style>`
  },

  json: {
    extension: ['json'],
    name: 'JSON',
    category: 'data',
    icon: 'ri-braces-fill',
    monacoLanguage: 'json',
    defaultContent: '{\n  "name": "example",\n  "version": "1.0.0"\n}'
  }
}
```

#### æ–‡ä»¶ç±»å‹æ³¨å†Œç³»ç»Ÿ
```typescript
// services/file-type-registry.ts
class FileTypeRegistry {
  private types = new Map<string, FileTypeDefinition>()

  // æ³¨å†Œæ–°æ–‡ä»¶ç±»å‹
  register(type: FileTypeDefinition): void {
    type.extension.forEach(ext => {
      this.types.set(ext.toLowerCase(), type)
    })
  }

  // æ‰¹é‡æ³¨å†Œ
  registerBatch(types: FileTypeDefinition[]): void {
    types.forEach(type => this.register(type))
  }

  // è·å–æ–‡ä»¶ç±»å‹
  getType(filename: string): FileTypeDefinition | null {
    const ext = this.getExtension(filename)
    return this.types.get(ext) || null
  }

  // è·å–æ‰€æœ‰æ”¯æŒçš„ç±»å‹
  getAllTypes(): FileTypeDefinition[] {
    return Array.from(new Set(this.types.values()))
  }

  // æŒ‰åˆ†ç±»è·å–ç±»å‹
  getTypesByCategory(category: string): FileTypeDefinition[] {
    return this.getAllTypes().filter(type => type.category === category)
  }

  private getExtension(filename: string): string {
    return filename.split('.').pop()?.toLowerCase() || ''
  }
}

export const fileTypeRegistry = new FileTypeRegistry()

// åˆå§‹åŒ–å†…ç½®ç±»å‹
fileTypeRegistry.registerBatch(Object.values(FILE_TYPES))
```

### 2. Monaco Editor è¯­è¨€æ”¯æŒæ‰©å±•

#### è‡ªå®šä¹‰è¯­è¨€æ”¯æŒ
```typescript
// services/language-support.ts
import * as monaco from 'monaco-editor'

export class LanguageSupportService {
  // æ³¨å†Œè‡ªå®šä¹‰è¯­è¨€
  static registerCustomLanguage(languageId: string, config: {
    extensions: string[]
    aliases: string[]
    mimetypes?: string[]
    tokenizer?: any
    languageConfiguration?: any
  }): void {
    // æ³¨å†Œè¯­è¨€
    monaco.languages.register({
      id: languageId,
      extensions: config.extensions,
      aliases: config.aliases,
      mimetypes: config.mimetypes
    })

    // è®¾ç½®è¯­è¨€é…ç½®
    if (config.languageConfiguration) {
      monaco.languages.setLanguageConfiguration(languageId, config.languageConfiguration)
    }

    // è®¾ç½®è¯æ³•åˆ†æå™¨
    if (config.tokenizer) {
      monaco.languages.setMonarchTokensProvider(languageId, config.tokenizer)
    }
  }

  // MDX æ”¯æŒç¤ºä¾‹
  static registerMDX(): void {
    this.registerCustomLanguage('mdx', {
      extensions: ['.mdx'],
      aliases: ['MDX', 'mdx'],
      tokenizer: {
        root: [
          // JSX è¯­æ³•
          [/<\/?[a-zA-Z][\w\-]*/, 'tag'],
          [/{[^}]*}/, 'delimiter.bracket'],
          
          // Markdown è¯­æ³•
          [/^#.*$/, 'header'],
          [/\*\*.*?\*\*/, 'strong'],
          [/\*.*?\*/, 'emphasis'],
          [/`.*?`/, 'code'],
          
          // å…¶ä»–æ ‡è®°
          [/.*/, 'text']
        ]
      },
      languageConfiguration: {
        comments: {
          blockComment: ['{/*', '*/}']
        },
        brackets: [
          ['{', '}'],
          ['[', ']'],
          ['(', ')']
        ],
        autoClosingPairs: [
          { open: '{', close: '}' },
          { open: '[', close: ']' },
          { open: '(', close: ')' },
          { open: '"', close: '"' },
          { open: "'", close: "'" }
        ]
      }
    })
  }

  // YAML æ”¯æŒå¢å¼º
  static registerEnhancedYAML(): void {
    // æ·»åŠ  YAML ç‰¹å®šçš„æ™ºèƒ½æç¤º
    monaco.languages.registerCompletionItemProvider('yaml', {
      provideCompletionItems: (model, position) => {
        const suggestions = [
          {
            label: 'apiVersion',
            kind: monaco.languages.CompletionItemKind.Property,
            insertText: 'apiVersion: ',
            documentation: 'API version'
          },
          {
            label: 'kind',
            kind: monaco.languages.CompletionItemKind.Property,
            insertText: 'kind: ',
            documentation: 'Resource kind'
          }
        ]
        return { suggestions }
      }
    })
  }

  // SQL æ”¯æŒ
  static registerSQL(): void {
    this.registerCustomLanguage('sql', {
      extensions: ['.sql'],
      aliases: ['SQL', 'sql'],
      tokenizer: {
        root: [
          // SQL å…³é”®å­—
          [/\b(SELECT|FROM|WHERE|INSERT|UPDATE|DELETE|CREATE|DROP|ALTER|TABLE)\b/i, 'keyword'],
          
          // å‡½æ•°
          [/\b(COUNT|SUM|AVG|MAX|MIN|DISTINCT)\b/i, 'function'],
          
          // å­—ç¬¦ä¸²
          [/'([^'\\]|\\.)*'/, 'string'],
          [/"([^"\\]|\\.)*"/, 'string'],
          
          // æ•°å­—
          [/\d+/, 'number'],
          
          // æ³¨é‡Š
          [/--.*$/, 'comment'],
          [/\/\*[\s\S]*?\*\//, 'comment']
        ]
      }
    })
  }
}

// åˆå§‹åŒ–è¯­è¨€æ”¯æŒ
LanguageSupportService.registerMDX()
LanguageSupportService.registerEnhancedYAML()
LanguageSupportService.registerSQL()
```

### 3. è‡ªå®šä¹‰æ–‡ä»¶æ¸²æŸ“å™¨

#### æ¸²æŸ“å™¨æ¥å£å®šä¹‰
```typescript
// types/renderer.ts
export interface FileRenderer {
  // æ¸²æŸ“å™¨ID
  id: string
  
  // æ”¯æŒçš„æ–‡ä»¶ç±»å‹
  supportedTypes: string[]
  
  // æ¸²æŸ“æ–‡ä»¶å†…å®¹
  render(content: string, metadata?: any): Promise<RenderedContent>
  
  // æ˜¯å¦æ”¯æŒå®æ—¶é¢„è§ˆ
  supportsLivePreview: boolean
  
  // è·å–å·¥å…·æ æŒ‰é’®
  getToolbarButtons?(): ToolbarButton[]
}

export interface RenderedContent {
  html: string
  css?: string
  scripts?: string[]
  interactive?: boolean
}

export interface ToolbarButton {
  id: string
  label: string
  icon: string
  action: () => void
}
```

#### Markdown æ¸²æŸ“å™¨å®ç°
```typescript
// renderers/markdown-renderer.ts
import MarkdownIt from 'markdown-it'
import hljs from 'highlight.js'

export class MarkdownRenderer implements FileRenderer {
  id = 'markdown'
  supportedTypes = ['md', 'markdown']
  supportsLivePreview = true

  private md: MarkdownIt

  constructor() {
    this.md = new MarkdownIt({
      html: true,
      highlight: (str, lang) => {
        if (lang && hljs.getLanguage(lang)) {
          try {
            return hljs.highlight(str, { language: lang }).value
          } catch (__) {}
        }
        return ''
      }
    })

    // æ·»åŠ æ’ä»¶
    this.md.use(require('markdown-it-footnote'))
    this.md.use(require('markdown-it-task-lists'))
    this.md.use(require('markdown-it-emoji'))
  }

  async render(content: string): Promise<RenderedContent> {
    const html = this.md.render(content)
    
    return {
      html,
      css: `
        .markdown-body {
          max-width: none;
          padding: 20px;
        }
        .markdown-body pre {
          background: #f6f8fa;
          padding: 16px;
          border-radius: 6px;
        }
        .markdown-body code {
          background: #f6f8fa;
          padding: 2px 4px;
          border-radius: 3px;
        }
      `,
      interactive: false
    }
  }

  getToolbarButtons(): ToolbarButton[] {
    return [
      {
        id: 'bold',
        label: 'åŠ ç²—',
        icon: 'ri-bold',
        action: () => this.insertFormat('**', '**')
      },
      {
        id: 'italic',
        label: 'æ–œä½“',
        icon: 'ri-italic',
        action: () => this.insertFormat('*', '*')
      },
      {
        id: 'code',
        label: 'ä»£ç ',
        icon: 'ri-code-line',
        action: () => this.insertFormat('`', '`')
      },
      {
        id: 'link',
        label: 'é“¾æ¥',
        icon: 'ri-link',
        action: () => this.insertFormat('[', '](url)')
      }
    ]
  }

  private insertFormat(before: string, after: string): void {
    // åœ¨ç¼–è¾‘å™¨ä¸­æ’å…¥æ ¼å¼åŒ–æ–‡æœ¬
    const editor = getCurrentEditor()
    if (editor) {
      const selection = editor.getSelection()
      const selectedText = editor.getModel()?.getValueInRange(selection) || ''
      const newText = `${before}${selectedText}${after}`
      
      editor.executeEdits('markdown-format', [{
        range: selection,
        text: newText
      }])
    }
  }
}
```

#### å›¾ç‰‡é¢„è§ˆæ¸²æŸ“å™¨
```typescript
// renderers/image-renderer.ts
export class ImageRenderer implements FileRenderer {
  id = 'image'
  supportedTypes = ['jpg', 'jpeg', 'png', 'gif', 'svg', 'webp']
  supportsLivePreview = false

  async render(content: string, metadata?: { filePath?: string }): Promise<RenderedContent> {
    const imageSrc = metadata?.filePath || `data:image/png;base64,${content}`
    
    const html = `
      <div class="image-viewer">
        <div class="image-container">
          <img src="${imageSrc}" alt="å›¾ç‰‡é¢„è§ˆ" />
        </div>
        <div class="image-info">
          <div class="image-actions">
            <button class="zoom-in">æ”¾å¤§</button>
            <button class="zoom-out">ç¼©å°</button>
            <button class="reset-zoom">é‡ç½®</button>
            <button class="download">ä¸‹è½½</button>
          </div>
        </div>
      </div>
    `

    const css = `
      .image-viewer {
        display: flex;
        flex-direction: column;
        height: 100%;
        background: #f5f5f5;
      }
      .image-container {
        flex: 1;
        display: flex;
        justify-content: center;
        align-items: center;
        overflow: auto;
        padding: 20px;
      }
      .image-container img {
        max-width: 100%;
        max-height: 100%;
        transition: transform 0.3s ease;
        box-shadow: 0 4px 8px rgba(0,0,0,0.1);
      }
      .image-actions {
        display: flex;
        gap: 10px;
        padding: 15px;
        background: white;
        border-top: 1px solid #ddd;
      }
      .image-actions button {
        padding: 8px 16px;
        border: 1px solid #ddd;
        border-radius: 4px;
        background: white;
        cursor: pointer;
      }
    `

    const scripts = [`
      function initImageViewer() {
        let scale = 1;
        const img = document.querySelector('.image-container img');
        
        document.querySelector('.zoom-in').onclick = () => {
          scale *= 1.2;
          img.style.transform = \`scale(\${scale})\`;
        };
        
        document.querySelector('.zoom-out').onclick = () => {
          scale /= 1.2;
          img.style.transform = \`scale(\${scale})\`;
        };
        
        document.querySelector('.reset-zoom').onclick = () => {
          scale = 1;
          img.style.transform = 'scale(1)';
        };
      }
      
      initImageViewer();
    `]

    return { html, css, scripts, interactive: true }
  }
}
```

### 4. æ¸²æŸ“å™¨æ³¨å†Œç³»ç»Ÿ

```typescript
// services/renderer-registry.ts
class RendererRegistry {
  private renderers = new Map<string, FileRenderer>()

  register(renderer: FileRenderer): void {
    this.renderers.set(renderer.id, renderer)
  }

  getRenderer(fileExtension: string): FileRenderer | null {
    for (const renderer of this.renderers.values()) {
      if (renderer.supportedTypes.includes(fileExtension)) {
        return renderer
      }
    }
    return null
  }

  getAllRenderers(): FileRenderer[] {
    return Array.from(this.renderers.values())
  }
}

export const rendererRegistry = new RendererRegistry()

// æ³¨å†Œå†…ç½®æ¸²æŸ“å™¨
rendererRegistry.register(new MarkdownRenderer())
rendererRegistry.register(new ImageRenderer())
```

## ğŸ”§ ç¼–è¾‘å™¨åŠŸèƒ½æ‰©å±•

### 1. ç¼–è¾‘å™¨æ’ä»¶ç³»ç»Ÿ

#### æ’ä»¶æ¥å£å®šä¹‰
```typescript
// types/plugin.ts
export interface EditorPlugin {
  id: string
  name: string
  version: string
  description?: string
  
  // æ’ä»¶ç”Ÿå‘½å‘¨æœŸ
  onLoad?(editor: monaco.editor.IStandaloneCodeEditor): void
  onUnload?(editor: monaco.editor.IStandaloneCodeEditor): void
  
  // ç¼–è¾‘å™¨äº‹ä»¶
  onContentChange?(content: string): void
  onSelectionChange?(selection: monaco.Selection): void
  onCursorPositionChange?(position: monaco.Position): void
  
  // å‘½ä»¤æ³¨å†Œ
  commands?: EditorCommand[]
  
  // å¿«æ·é”®ç»‘å®š
  keybindings?: KeyBinding[]
  
  // UI æ‰©å±•
  toolbarButtons?: ToolbarButton[]
  contextMenuItems?: ContextMenuItem[]
}

export interface EditorCommand {
  id: string
  label: string
  execute: (editor: monaco.editor.IStandaloneCodeEditor, ...args: any[]) => void
}

export interface KeyBinding {
  key: string
  command: string
  when?: string
}

export interface ContextMenuItem {
  id: string
  label: string
  group?: string
  order?: number
  execute: (editor: monaco.editor.IStandaloneCodeEditor) => void
}
```

#### è‡ªåŠ¨æ ¼å¼åŒ–æ’ä»¶ç¤ºä¾‹
```typescript
// plugins/auto-format-plugin.ts
export class AutoFormatPlugin implements EditorPlugin {
  id = 'auto-format'
  name = 'è‡ªåŠ¨æ ¼å¼åŒ–'
  version = '1.0.0'
  description = 'ä¿å­˜æ—¶è‡ªåŠ¨æ ¼å¼åŒ–ä»£ç '

  private editor?: monaco.editor.IStandaloneCodeEditor

  onLoad(editor: monaco.editor.IStandaloneCodeEditor): void {
    this.editor = editor
    
    // ç›‘å¬ä¿å­˜äº‹ä»¶
    editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.KeyS, () => {
      this.formatAndSave()
    })
  }

  onUnload(): void {
    this.editor = undefined
  }

  commands: EditorCommand[] = [
    {
      id: 'format-document',
      label: 'æ ¼å¼åŒ–æ–‡æ¡£',
      execute: (editor) => {
        editor.getAction('editor.action.formatDocument')?.run()
      }
    }
  ]

  keybindings: KeyBinding[] = [
    {
      key: 'Shift+Alt+F',
      command: 'format-document'
    }
  ]

  toolbarButtons: ToolbarButton[] = [
    {
      id: 'format',
      label: 'æ ¼å¼åŒ–',
      icon: 'ri-code-box-line',
      action: () => {
        this.editor?.getAction('editor.action.formatDocument')?.run()
      }
    }
  ]

  private async formatAndSave(): void {
    if (!this.editor) return
    
    // å…ˆæ ¼å¼åŒ–
    await this.editor.getAction('editor.action.formatDocument')?.run()
    
    // å†ä¿å­˜
    const saveEvent = new CustomEvent('editor-save', {
      detail: { content: this.editor.getValue() }
    })
    document.dispatchEvent(saveEvent)
  }
}
```

#### ä»£ç ç‰‡æ®µæ’ä»¶
```typescript
// plugins/snippet-plugin.ts
export class SnippetPlugin implements EditorPlugin {
  id = 'snippets'
  name = 'ä»£ç ç‰‡æ®µ'
  version = '1.0.0'

  private snippets: Record<string, CodeSnippet> = {
    'vue-component': {
      prefix: 'vcomp',
      body: [
        '<template>',
        '  <div>',
        '    $1',
        '  </div>',
        '</template>',
        '',
        '<script setup lang="ts">',
        '$2',
        '</script>',
        '',
        '<style scoped>',
        '$3',
        '</style>'
      ],
      description: 'Vue 3 ç»„ä»¶æ¨¡æ¿'
    },
    
    'function': {
      prefix: 'fn',
      body: [
        'function ${1:functionName}(${2:params}) {',
        '  $3',
        '  return $4',
        '}'
      ],
      description: 'JavaScript å‡½æ•°'
    }
  }

  onLoad(editor: monaco.editor.IStandaloneCodeEditor): void {
    // æ³¨å†Œä»£ç ç‰‡æ®µ
    Object.entries(this.snippets).forEach(([key, snippet]) => {
      monaco.languages.registerCompletionItemProvider('*', {
        provideCompletionItems: (model, position) => {
          const word = model.getWordUntilPosition(position)
          const range = {
            startLineNumber: position.lineNumber,
            endLineNumber: position.lineNumber,
            startColumn: word.startColumn,
            endColumn: word.endColumn
          }

          if (word.word === snippet.prefix) {
            return {
              suggestions: [{
                label: snippet.prefix,
                kind: monaco.languages.CompletionItemKind.Snippet,
                documentation: snippet.description,
                insertText: snippet.body.join('\n'),
                insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
                range
              }]
            }
          }
          return { suggestions: [] }
        }
      })
    })
  }

  commands: EditorCommand[] = [
    {
      id: 'insert-snippet',
      label: 'æ’å…¥ä»£ç ç‰‡æ®µ',
      execute: (editor) => {
        this.showSnippetPicker(editor)
      }
    }
  ]

  private showSnippetPicker(editor: monaco.editor.IStandaloneCodeEditor): void {
    // æ˜¾ç¤ºä»£ç ç‰‡æ®µé€‰æ‹©å™¨
    const picker = document.createElement('div')
    picker.className = 'snippet-picker'
    picker.innerHTML = `
      <div class="snippet-list">
        ${Object.entries(this.snippets).map(([key, snippet]) => `
          <div class="snippet-item" data-key="${key}">
            <div class="snippet-prefix">${snippet.prefix}</div>
            <div class="snippet-description">${snippet.description}</div>
          </div>
        `).join('')}
      </div>
    `

    picker.addEventListener('click', (e) => {
      const item = (e.target as Element).closest('.snippet-item')
      if (item) {
        const key = item.getAttribute('data-key')!
        const snippet = this.snippets[key]
        
        const position = editor.getPosition()!
        editor.executeEdits('insert-snippet', [{
          range: new monaco.Range(position.lineNumber, position.column, position.lineNumber, position.column),
          text: snippet.body.join('\n')
        }])
        
        picker.remove()
      }
    })

    document.body.appendChild(picker)
  }
}

interface CodeSnippet {
  prefix: string
  body: string[]
  description: string
}
```

### 2. ä¸»é¢˜æ‰©å±•ç³»ç»Ÿ

#### ä¸»é¢˜å®šä¹‰æ¥å£
```typescript
// types/theme.ts
export interface EditorTheme {
  id: string
  name: string
  type: 'light' | 'dark'
  
  // Monaco ä¸»é¢˜å®šä¹‰
  monacoTheme: monaco.editor.IStandaloneThemeData
  
  // UI ä¸»é¢˜å˜é‡
  uiColors: {
    primary: string
    background: string
    surface: string
    text: string
    textSecondary: string
    border: string
    hover: string
    active: string
  }
  
  // è‡ªå®šä¹‰ CSS å˜é‡
  cssVariables?: Record<string, string>
}
```

#### è‡ªå®šä¹‰ä¸»é¢˜ç¤ºä¾‹
```typescript
// themes/custom-themes.ts
export const draculaTheme: EditorTheme = {
  id: 'dracula',
  name: 'Dracula',
  type: 'dark',
  
  monacoTheme: {
    base: 'vs-dark',
    inherit: true,
    rules: [
      { token: 'comment', foreground: '6272a4', fontStyle: 'italic' },
      { token: 'keyword', foreground: 'ff79c6' },
      { token: 'string', foreground: 'f1fa8c' },
      { token: 'number', foreground: 'bd93f9' },
      { token: 'function', foreground: '50fa7b' },
      { token: 'class', foreground: '8be9fd' }
    ],
    colors: {
      'editor.background': '#282a36',
      'editor.foreground': '#f8f8f2',
      'editor.lineHighlightBackground': '#44475a',
      'editor.selectionBackground': '#44475a',
      'editorCursor.foreground': '#f8f8f0',
      'editorWhitespace.foreground': '#6272a4'
    }
  },
  
  uiColors: {
    primary: '#bd93f9',
    background: '#282a36',
    surface: '#44475a',
    text: '#f8f8f2',
    textSecondary: '#6272a4',
    border: '#6272a4',
    hover: '#44475a',
    active: '#bd93f9'
  },
  
  cssVariables: {
    '--sidebar-bg': '#21222c',
    '--toolbar-bg': '#191a21',
    '--button-hover': '#44475a'
  }
}

export const githubLightTheme: EditorTheme = {
  id: 'github-light',
  name: 'GitHub Light',
  type: 'light',
  
  monacoTheme: {
    base: 'vs',
    inherit: true,
    rules: [
      { token: 'comment', foreground: '6a737d', fontStyle: 'italic' },
      { token: 'keyword', foreground: 'd73a49' },
      { token: 'string', foreground: '032f62' },
      { token: 'number', foreground: '005cc5' },
      { token: 'function', foreground: '6f42c1' }
    ],
    colors: {
      'editor.background': '#ffffff',
      'editor.foreground': '#24292e',
      'editor.lineHighlightBackground': '#f6f8fa',
      'editor.selectionBackground': '#c8e1ff'
    }
  },
  
  uiColors: {
    primary: '#0366d6',
    background: '#ffffff',
    surface: '#f6f8fa',
    text: '#24292e',
    textSecondary: '#586069',
    border: '#e1e4e8',
    hover: '#f6f8fa',
    active: '#0366d6'
  }
}
```

#### ä¸»é¢˜ç®¡ç†å™¨
```typescript
// services/theme-manager.ts
class ThemeManager {
  private themes = new Map<string, EditorTheme>()
  private currentTheme: EditorTheme | null = null

  register(theme: EditorTheme): void {
    this.themes.set(theme.id, theme)
    
    // æ³¨å†Œ Monaco ä¸»é¢˜
    monaco.editor.defineTheme(theme.id, theme.monacoTheme)
  }

  setTheme(themeId: string): void {
    const theme = this.themes.get(themeId)
    if (!theme) return
    
    this.currentTheme = theme
    
    // åº”ç”¨ Monaco ä¸»é¢˜
    monaco.editor.setTheme(themeId)
    
    // åº”ç”¨ UI ä¸»é¢˜
    this.applyUITheme(theme)
    
    // ä¿å­˜ä¸»é¢˜åå¥½
    localStorage.setItem('editor-theme', themeId)
  }

  private applyUITheme(theme: EditorTheme): void {
    const root = document.documentElement
    
    // åº”ç”¨ UI é¢œè‰²
    Object.entries(theme.uiColors).forEach(([key, value]) => {
      root.style.setProperty(`--color-${key}`, value)
    })
    
    // åº”ç”¨è‡ªå®šä¹‰ CSS å˜é‡
    if (theme.cssVariables) {
      Object.entries(theme.cssVariables).forEach(([key, value]) => {
        root.style.setProperty(key, value)
      })
    }
    
    // è®¾ç½®ä¸»é¢˜ç±»å‹
    root.setAttribute('data-theme', theme.type)
  }

  getCurrentTheme(): EditorTheme | null {
    return this.currentTheme
  }

  getAllThemes(): EditorTheme[] {
    return Array.from(this.themes.values())
  }

  // ä»åå¥½è®¾ç½®ä¸­æ¢å¤ä¸»é¢˜
  restoreTheme(): void {
    const savedTheme = localStorage.getItem('editor-theme')
    if (savedTheme && this.themes.has(savedTheme)) {
      this.setTheme(savedTheme)
    }
  }
}

export const themeManager = new ThemeManager()

// æ³¨å†Œå†…ç½®ä¸»é¢˜
themeManager.register(draculaTheme)
themeManager.register(githubLightTheme)
```

## ğŸ¤– AIæœåŠ¡æ‰©å±•

### 1. æ–°AIæä¾›å•†é›†æˆ

#### OpenAI æœåŠ¡å®ç°
```typescript
// services/ai/openai.ts
import { AIServiceBase } from './base'

export class OpenAIService extends AIServiceBase {
  constructor(config: AIConfig) {
    super(config)
  }

  async chat(messages: ChatMessage[]): Promise<string> {
    try {
      const response = await fetch('https://api.openai.com/v1/chat/completions', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${this.config.apiKey}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          model: this.config.model || 'gpt-3.5-turbo',
          messages: messages,
          temperature: 0.7,
          max_tokens: 2000
        })
      })

      const data = await response.json()
      
      if (!response.ok) {
        throw new Error(data.error?.message || 'OpenAI API è¯·æ±‚å¤±è´¥')
      }

      return data.choices[0].message.content
    } catch (error) {
      console.error('OpenAI æœåŠ¡é”™è¯¯:', error)
      throw error
    }
  }

  async streamChat(
    messages: ChatMessage[], 
    onChunk: (chunk: StreamChunk) => void
  ): Promise<void> {
    try {
      const response = await fetch('https://api.openai.com/v1/chat/completions', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${this.config.apiKey}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          model: this.config.model || 'gpt-3.5-turbo',
          messages: messages,
          temperature: 0.7,
          max_tokens: 2000,
          stream: true
        })
      })

      const reader = response.body?.getReader()
      if (!reader) throw new Error('æ— æ³•è¯»å–å“åº”æµ')

      const decoder = new TextDecoder()

      while (true) {
        const { done, value } = await reader.read()
        if (done) break

        const chunk = decoder.decode(value)
        const lines = chunk.split('\n')

        for (const line of lines) {
          if (line.startsWith('data: ')) {
            const data = line.slice(6)
            if (data === '[DONE]') continue

            try {
              const parsed = JSON.parse(data)
              const content = parsed.choices[0]?.delta?.content
              
              if (content) {
                onChunk({ content, finished: false })
              }
            } catch (e) {
              // å¿½ç•¥è§£æé”™è¯¯
            }
          }
        }
      }

      onChunk({ content: '', finished: true })
    } catch (error) {
      console.error('OpenAI æµå¼è¯·æ±‚é”™è¯¯:', error)
      throw error
    }
  }

  isConfigured(): boolean {
    return !!(this.config.apiKey && this.config.apiKey.length > 0)
  }
}
```

#### Claude æœåŠ¡å®ç°
```typescript
// services/ai/claude.ts
export class ClaudeService extends AIServiceBase {
  async chat(messages: ChatMessage[]): Promise<string> {
    try {
      const response = await fetch('https://api.anthropic.com/v1/messages', {
        method: 'POST',
        headers: {
          'x-api-key': this.config.apiKey!,
          'Content-Type': 'application/json',
          'anthropic-version': '2023-06-01'
        },
        body: JSON.stringify({
          model: this.config.model || 'claude-3-sonnet-20240229',
          max_tokens: 2000,
          messages: messages
        })
      })

      const data = await response.json()
      
      if (!response.ok) {
        throw new Error(data.error?.message || 'Claude API è¯·æ±‚å¤±è´¥')
      }

      return data.content[0].text
    } catch (error) {
      console.error('Claude æœåŠ¡é”™è¯¯:', error)
      throw error
    }
  }

  // å®ç°å…¶ä»–å¿…éœ€æ–¹æ³•...
}
```

### 2. ä¸“ä¸šåŒ–AIåŠ©æ‰‹

#### ä»£ç å®¡æŸ¥åŠ©æ‰‹
```typescript
// services/ai/code-reviewer.ts
export class CodeReviewerAI {
  constructor(private aiService: AIServiceBase) {}

  async reviewCode(code: string, language: string): Promise<CodeReviewResult> {
    const prompt = `ä½œä¸ºä¸€ä¸ªèµ„æ·±çš„${language}å¼€å‘è€…ï¼Œè¯·å®¡æŸ¥ä»¥ä¸‹ä»£ç ï¼š

\`\`\`${language}
${code}
\`\`\`

è¯·ä»ä»¥ä¸‹æ–¹é¢è¿›è¡Œåˆ†æï¼š
1. ä»£ç è´¨é‡å’Œæœ€ä½³å®è·µ
2. æ½œåœ¨çš„bugå’Œå®‰å…¨é—®é¢˜
3. æ€§èƒ½ä¼˜åŒ–å»ºè®®
4. ä»£ç å¯è¯»æ€§å’Œç»´æŠ¤æ€§
5. å…·ä½“çš„æ”¹è¿›å»ºè®®

è¯·ä»¥JSONæ ¼å¼è¿”å›ç»“æœï¼š
{
  "score": 85,
  "issues": [...],
  "suggestions": [...],
  "improvements": "..."
}`

    try {
      const response = await this.aiService.chat([
        { role: 'user', content: prompt }
      ])

      return JSON.parse(response)
    } catch (error) {
      console.error('ä»£ç å®¡æŸ¥å¤±è´¥:', error)
      throw error
    }
  }
}

interface CodeReviewResult {
  score: number
  issues: CodeIssue[]
  suggestions: string[]
  improvements: string
}

interface CodeIssue {
  type: 'bug' | 'security' | 'performance' | 'style'
  severity: 'low' | 'medium' | 'high'
  line?: number
  message: string
  suggestion?: string
}
```

#### æ–‡æ¡£ç”ŸæˆåŠ©æ‰‹
```typescript
// services/ai/doc-generator.ts
export class DocumentationAI {
  constructor(private aiService: AIServiceBase) {}

  async generateAPIDoc(code: string): Promise<string> {
    const prompt = `è¯·ä¸ºä»¥ä¸‹ä»£ç ç”ŸæˆAPIæ–‡æ¡£ï¼š

${code}

è¦æ±‚ï¼š
1. ä½¿ç”¨Markdownæ ¼å¼
2. åŒ…å«å‡½æ•°/æ–¹æ³•çš„æè¿°
3. åˆ—å‡ºå‚æ•°å’Œè¿”å›å€¼
4. æä¾›ä½¿ç”¨ç¤ºä¾‹
5. æ³¨æ˜å¯èƒ½çš„å¼‚å¸¸æƒ…å†µ`

    return await this.aiService.chat([
      { role: 'user', content: prompt }
    ])
  }

  async generateReadme(projectInfo: ProjectInfo): Promise<string> {
    const prompt = `è¯·ä¸ºä»¥ä¸‹é¡¹ç›®ç”ŸæˆREADME.mdæ–‡æ¡£ï¼š

é¡¹ç›®åç§°: ${projectInfo.name}
é¡¹ç›®æè¿°: ${projectInfo.description}
æŠ€æœ¯æ ˆ: ${projectInfo.technologies.join(', ')}
ä¸»è¦åŠŸèƒ½: ${projectInfo.features.join(', ')}

è¦æ±‚åŒ…å«ï¼š
1. é¡¹ç›®ç®€ä»‹
2. åŠŸèƒ½ç‰¹æ€§
3. å®‰è£…è¯´æ˜
4. ä½¿ç”¨æŒ‡å—
5. APIæ–‡æ¡£
6. è´¡çŒ®æŒ‡å—
7. è®¸å¯è¯ä¿¡æ¯`

    return await this.aiService.chat([
      { role: 'user', content: prompt }
    ])
  }
}

interface ProjectInfo {
  name: string
  description: string
  technologies: string[]
  features: string[]
}
```

### 3. AIå·¥ä½œæµå¼•æ“

#### å·¥ä½œæµå®šä¹‰
```typescript
// types/workflow.ts
export interface AIWorkflow {
  id: string
  name: string
  description: string
  steps: WorkflowStep[]
  triggers: WorkflowTrigger[]
}

export interface WorkflowStep {
  id: string
  type: 'ai-chat' | 'transform' | 'validate' | 'save'
  config: any
  nextSteps?: string[]
}

export interface WorkflowTrigger {
  type: 'file-save' | 'text-selection' | 'manual'
  conditions?: any
}
```

#### å·¥ä½œæµç¤ºä¾‹
```typescript
// workflows/code-optimization.ts
export const codeOptimizationWorkflow: AIWorkflow = {
  id: 'code-optimization',
  name: 'ä»£ç ä¼˜åŒ–å·¥ä½œæµ',
  description: 'è‡ªåŠ¨åˆ†æå’Œä¼˜åŒ–ä»£ç ',
  
  triggers: [
    {
      type: 'file-save',
      conditions: { fileType: ['js', 'ts', 'py'] }
    }
  ],
  
  steps: [
    {
      id: 'analyze-code',
      type: 'ai-chat',
      config: {
        prompt: 'åˆ†æä»¥ä¸‹ä»£ç çš„æ€§èƒ½é—®é¢˜ï¼š{content}',
        aiService: 'openai'
      },
      nextSteps: ['suggest-optimizations']
    },
    {
      id: 'suggest-optimizations',
      type: 'ai-chat',
      config: {
        prompt: 'åŸºäºåˆ†æç»“æœï¼Œæä¾›å…·ä½“çš„ä¼˜åŒ–å»ºè®®ï¼š{analysis}',
        aiService: 'claude'
      },
      nextSteps: ['apply-optimizations']
    },
    {
      id: 'apply-optimizations',
      type: 'transform',
      config: {
        action: 'show-suggestions-panel'
      }
    }
  ]
}
```

## ğŸ¨ UI/UXæ‰©å±•

### 1. è‡ªå®šä¹‰ç»„ä»¶å¼€å‘

#### ç»„ä»¶æ¥å£è§„èŒƒ
```typescript
// types/component.ts
export interface CustomComponent {
  name: string
  props: ComponentProps
  emits: ComponentEmits
  slots?: ComponentSlots
  
  // ç»„ä»¶å…ƒæ•°æ®
  category: 'editor' | 'sidebar' | 'toolbar' | 'modal'
  version: string
  dependencies?: string[]
}

export interface ComponentProps {
  [key: string]: {
    type: 'string' | 'number' | 'boolean' | 'object' | 'array'
    required?: boolean
    default?: any
    description?: string
  }
}

export interface ComponentEmits {
  [key: string]: {
    payload?: any
    description?: string
  }
}

export interface ComponentSlots {
  [key: string]: {
    props?: any
    description?: string
  }
}
```

#### é«˜çº§æœç´¢ç»„ä»¶ç¤ºä¾‹
```vue
<!-- components/advanced-search/AdvancedSearch.vue -->
<template>
  <div class="advanced-search">
    <div class="search-header">
      <input
        v-model="searchQuery"
        class="search-input"
        placeholder="æœç´¢æ–‡ä»¶å’Œå†…å®¹..."
        @input="handleSearch"
      />
      <button
        class="filter-toggle"
        @click="showFilters = !showFilters"
      >
        <i class="ri-filter-line"></i>
      </button>
    </div>

    <div v-if="showFilters" class="search-filters">
      <div class="filter-group">
        <label>æ–‡ä»¶ç±»å‹</label>
        <div class="filter-options">
          <label v-for="type in fileTypes" :key="type">
            <input
              v-model="selectedTypes"
              type="checkbox"
              :value="type"
            />
            {{ type }}
          </label>
        </div>
      </div>

      <div class="filter-group">
        <label>ä¿®æ”¹æ—¶é—´</label>
        <select v-model="timeFilter">
          <option value="">å…¨éƒ¨</option>
          <option value="today">ä»Šå¤©</option>
          <option value="week">æœ¬å‘¨</option>
          <option value="month">æœ¬æœˆ</option>
        </select>
      </div>

      <div class="filter-group">
        <label>æ–‡ä»¶å¤§å°</label>
        <div class="size-range">
          <input
            v-model="sizeMin"
            type="number"
            placeholder="æœ€å°(KB)"
          />
          <span>-</span>
          <input
            v-model="sizeMax"
            type="number"
            placeholder="æœ€å¤§(KB)"
          />
        </div>
      </div>
    </div>

    <div class="search-results">
      <div
        v-for="result in searchResults"
        :key="result.id"
        class="search-result-item"
        @click="openFile(result.id)"
      >
        <div class="result-icon">
          <i :class="getFileIcon(result)"></i>
        </div>
        <div class="result-content">
          <div class="result-title">{{ result.name }}</div>
          <div class="result-path">{{ result.path }}</div>
          <div v-if="result.preview" class="result-preview">
            {{ result.preview }}
          </div>
        </div>
        <div class="result-meta">
          <span class="result-size">{{ formatSize(result.size) }}</span>
          <span class="result-date">{{ formatDate(result.updatedAt) }}</span>
        </div>
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, computed, watch } from 'vue'
import { fileSystem } from '@/services/file-system'
import type { FileEntry } from '@/types'

// Props
const props = defineProps<{
  files: FileEntry[]
}>()

// Emits
const emit = defineEmits<{
  'file-select': [fileId: string]
  'search-change': [query: string, filters: SearchFilters]
}>()

// æœç´¢çŠ¶æ€
const searchQuery = ref('')
const showFilters = ref(false)
const selectedTypes = ref<string[]>([])
const timeFilter = ref('')
const sizeMin = ref<number>()
const sizeMax = ref<number>()

// æœç´¢ç»“æœ
const searchResults = ref<SearchResult[]>([])

// æ–‡ä»¶ç±»å‹åˆ—è¡¨
const fileTypes = computed(() => {
  const types = new Set<string>()
  props.files.forEach(file => {
    const ext = file.name.split('.').pop()
    if (ext) types.add(ext)
  })
  return Array.from(types)
})

// æœç´¢é€»è¾‘
const handleSearch = async () => {
  const filters: SearchFilters = {
    types: selectedTypes.value,
    timeFilter: timeFilter.value,
    sizeRange: {
      min: sizeMin.value,
      max: sizeMax.value
    }
  }

  emit('search-change', searchQuery.value, filters)

  // æ‰§è¡Œæœç´¢
  searchResults.value = await performSearch(searchQuery.value, filters)
}

const performSearch = async (query: string, filters: SearchFilters): Promise<SearchResult[]> => {
  let results = props.files

  // æ–‡æœ¬æœç´¢
  if (query) {
    results = results.filter(file => 
      file.name.toLowerCase().includes(query.toLowerCase()) ||
      file.content.toLowerCase().includes(query.toLowerCase())
    )
  }

  // ç±»å‹è¿‡æ»¤
  if (filters.types.length > 0) {
    results = results.filter(file => {
      const ext = file.name.split('.').pop()
      return ext && filters.types.includes(ext)
    })
  }

  // æ—¶é—´è¿‡æ»¤
  if (filters.timeFilter) {
    const now = new Date()
    const filterDate = getFilterDate(filters.timeFilter, now)
    results = results.filter(file => file.updatedAt >= filterDate)
  }

  // å¤§å°è¿‡æ»¤
  if (filters.sizeRange.min || filters.sizeRange.max) {
    results = results.filter(file => {
      const size = (file.size || 0) / 1024 // è½¬æ¢ä¸ºKB
      if (filters.sizeRange.min && size < filters.sizeRange.min) return false
      if (filters.sizeRange.max && size > filters.sizeRange.max) return false
      return true
    })
  }

  // ç”Ÿæˆæœç´¢ç»“æœ
  return results.map(file => ({
    id: file.id,
    name: file.name,
    path: getFilePath(file),
    size: file.size || 0,
    updatedAt: file.updatedAt,
    preview: getContentPreview(file.content, query)
  }))
}

// å·¥å…·å‡½æ•°
const openFile = (fileId: string) => {
  emit('file-select', fileId)
}

const getFileIcon = (result: SearchResult) => {
  const ext = result.name.split('.').pop()?.toLowerCase()
  // è¿”å›å¯¹åº”çš„å›¾æ ‡ç±»å
  return `ri-file-${ext || 'text'}-line`
}

const formatSize = (bytes: number) => {
  if (bytes === 0) return '0 B'
  const k = 1024
  const sizes = ['B', 'KB', 'MB', 'GB']
  const i = Math.floor(Math.log(bytes) / Math.log(k))
  return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i]
}

const formatDate = (date: Date) => {
  return new Intl.RelativeTimeFormatter('zh', { numeric: 'auto' })
    .format(Math.floor((date.getTime() - Date.now()) / (1000 * 60 * 60 * 24)), 'day')
}

// ç›‘å¬æœç´¢å˜åŒ–
watch([searchQuery, selectedTypes, timeFilter, sizeMin, sizeMax], handleSearch, { 
  deep: true 
})

// ç±»å‹å®šä¹‰
interface SearchFilters {
  types: string[]
  timeFilter: string
  sizeRange: {
    min?: number
    max?: number
  }
}

interface SearchResult {
  id: string
  name: string
  path: string
  size: number
  updatedAt: Date
  preview?: string
}
</script>

<style scoped>
.advanced-search {
  display: flex;
  flex-direction: column;
  height: 100%;
}

.search-header {
  display: flex;
  gap: 8px;
  padding: 12px;
  border-bottom: 1px solid var(--color-border);
}

.search-input {
  flex: 1;
  padding: 8px 12px;
  border: 1px solid var(--color-border);
  border-radius: 6px;
  font-size: 14px;
}

.filter-toggle {
  padding: 8px;
  border: 1px solid var(--color-border);
  border-radius: 6px;
  background: var(--color-surface);
  cursor: pointer;
}

.search-filters {
  padding: 16px;
  background: var(--color-surface);
  border-bottom: 1px solid var(--color-border);
}

.filter-group {
  margin-bottom: 16px;
}

.filter-group label {
  display: block;
  font-weight: 500;
  margin-bottom: 8px;
  color: var(--color-text);
}

.filter-options {
  display: flex;
  flex-wrap: wrap;
  gap: 12px;
}

.filter-options label {
  display: flex;
  align-items: center;
  gap: 4px;
  font-weight: normal;
  margin-bottom: 0;
}

.size-range {
  display: flex;
  align-items: center;
  gap: 8px;
}

.size-range input {
  flex: 1;
  padding: 6px 8px;
  border: 1px solid var(--color-border);
  border-radius: 4px;
}

.search-results {
  flex: 1;
  overflow-y: auto;
  padding: 8px;
}

.search-result-item {
  display: flex;
  align-items: center;
  gap: 12px;
  padding: 12px;
  border-radius: 6px;
  cursor: pointer;
  transition: background-color 0.2s;
}

.search-result-item:hover {
  background-color: var(--color-hover);
}

.result-icon {
  flex-shrink: 0;
  font-size: 18px;
  color: var(--color-primary);
}

.result-content {
  flex: 1;
  min-width: 0;
}

.result-title {
  font-weight: 500;
  color: var(--color-text);
  margin-bottom: 4px;
}

.result-path {
  font-size: 12px;
  color: var(--color-text-secondary);
  margin-bottom: 4px;
}

.result-preview {
  font-size: 12px;
  color: var(--color-text-secondary);
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.result-meta {
  flex-shrink: 0;
  text-align: right;
  font-size: 12px;
  color: var(--color-text-secondary);
}

.result-size,
.result-date {
  display: block;
  margin-bottom: 2px;
}
</style>
```

### 2. å“åº”å¼å¸ƒå±€æ‰©å±•

#### å¸ƒå±€æ¨¡å¼å®šä¹‰
```typescript
// types/layout.ts
export interface LayoutMode {
  id: string
  name: string
  description: string
  breakpoints: Breakpoint[]
  panels: PanelConfig[]
}

export interface Breakpoint {
  name: string
  minWidth: number
  maxWidth?: number
}

export interface PanelConfig {
  id: string
  position: 'left' | 'right' | 'top' | 'bottom' | 'center'
  size: string | number
  collapsible: boolean
  resizable: boolean
  visible: boolean
}
```

#### å¸ƒå±€ç®¡ç†å™¨
```typescript
// services/layout-manager.ts
class LayoutManager {
  private modes = new Map<string, LayoutMode>()
  private currentMode: LayoutMode | null = null
  private currentBreakpoint: Breakpoint | null = null

  register(mode: LayoutMode): void {
    this.modes.set(mode.id, mode)
  }

  setMode(modeId: string): void {
    const mode = this.modes.get(modeId)
    if (!mode) return

    this.currentMode = mode
    this.applyLayout()
  }

  private applyLayout(): void {
    if (!this.currentMode) return

    // æ£€æµ‹å½“å‰æ–­ç‚¹
    this.currentBreakpoint = this.detectBreakpoint()

    // åº”ç”¨é¢æ¿é…ç½®
    this.currentMode.panels.forEach(panel => {
      this.applyPanelConfig(panel)
    })
  }

  private detectBreakpoint(): Breakpoint | null {
    if (!this.currentMode) return null

    const width = window.innerWidth

    return this.currentMode.breakpoints.find(bp =>
      width >= bp.minWidth && (!bp.maxWidth || width <= bp.maxWidth)
    ) || null
  }

  private applyPanelConfig(config: PanelConfig): void {
    const element = document.querySelector(`[data-panel="${config.id}"]`)
    if (!element) return

    const htmlElement = element as HTMLElement

    // åº”ç”¨å°ºå¯¸
    if (typeof config.size === 'number') {
      htmlElement.style.flexBasis = `${config.size}px`
    } else {
      htmlElement.style.flexBasis = config.size
    }

    // åº”ç”¨å¯è§æ€§
    htmlElement.style.display = config.visible ? 'flex' : 'none'

    // åº”ç”¨å¯è°ƒæ•´å¤§å°
    if (config.resizable) {
      htmlElement.classList.add('resizable')
    } else {
      htmlElement.classList.remove('resizable')
    }
  }
}

export const layoutManager = new LayoutManager()

// æ³¨å†Œå†…ç½®å¸ƒå±€æ¨¡å¼
layoutManager.register({
  id: 'desktop',
  name: 'æ¡Œé¢å¸ƒå±€',
  description: 'é€‚åˆå¤§å±å¹•çš„ä¸‰æ å¸ƒå±€',
  breakpoints: [
    { name: 'desktop', minWidth: 1024 }
  ],
  panels: [
    { id: 'sidebar', position: 'left', size: '288px', collapsible: true, resizable: true, visible: true },
    { id: 'editor', position: 'center', size: '1fr', collapsible: false, resizable: false, visible: true },
    { id: 'ai-panel', position: 'right', size: '384px', collapsible: true, resizable: true, visible: true }
  ]
})

layoutManager.register({
  id: 'tablet',
  name: 'å¹³æ¿å¸ƒå±€',
  description: 'é€‚åˆä¸­ç­‰å±å¹•çš„ä¸¤æ å¸ƒå±€',
  breakpoints: [
    { name: 'tablet', minWidth: 768, maxWidth: 1023 }
  ],
  panels: [
    { id: 'sidebar', position: 'left', size: '320px', collapsible: true, resizable: false, visible: true },
    { id: 'editor', position: 'center', size: '1fr', collapsible: false, resizable: false, visible: true },
    { id: 'ai-panel', position: 'right', size: '0px', collapsible: true, resizable: false, visible: false }
  ]
})

layoutManager.register({
  id: 'mobile',
  name: 'ç§»åŠ¨å¸ƒå±€',
  description: 'é€‚åˆå°å±å¹•çš„å•æ å¸ƒå±€',
  breakpoints: [
    { name: 'mobile', minWidth: 0, maxWidth: 767 }
  ],
  panels: [
    { id: 'sidebar', position: 'left', size: '0px', collapsible: true, resizable: false, visible: false },
    { id: 'editor', position: 'center', size: '100%', collapsible: false, resizable: false, visible: true },
    { id: 'ai-panel', position: 'right', size: '0px', collapsible: true, resizable: false, visible: false }
  ]
})
```

## ğŸ”Œ é›†æˆæ‰©å±•

### 1. å¤–éƒ¨å·¥å…·é›†æˆ

#### Git é›†æˆ
```typescript
// services/git-integration.ts
export class GitIntegration {
  private repoPath: string

  constructor(repoPath: string) {
    this.repoPath = repoPath
  }

  async getStatus(): Promise<GitStatus> {
    // è°ƒç”¨ Git API æˆ–å‘½ä»¤è¡Œå·¥å…·
    const response = await this.executeGitCommand('status --porcelain')
    return this.parseGitStatus(response)
  }

  async commit(message: string, files?: string[]): Promise<void> {
    if (files) {
      await this.executeGitCommand(`add ${files.join(' ')}`)
    } else {
      await this.executeGitCommand('add .')
    }

    await this.executeGitCommand(`commit -m "${message}"`)
  }

  async createBranch(name: string): Promise<void> {
    await this.executeGitCommand(`checkout -b ${name}`)
  }

  async switchBranch(name: string): Promise<void> {
    await this.executeGitCommand(`checkout ${name}`)
  }

  private async executeGitCommand(command: string): Promise<string> {
    // å®ç° Git å‘½ä»¤æ‰§è¡Œ
    // å¯ä»¥ä½¿ç”¨ Web API æˆ– Electron çš„ child_process
    throw new Error('Git command execution not implemented')
  }

  private parseGitStatus(output: string): GitStatus {
    const files: GitFileStatus[] = []
    const lines = output.split('\n').filter(line => line.trim())

    for (const line of lines) {
      const status = line.substring(0, 2)
      const path = line.substring(3)

      files.push({
        path,
        status: this.parseFileStatus(status),
        staged: status[0] !== ' ',
        modified: status[1] !== ' '
      })
    }

    return { files }
  }

  private parseFileStatus(status: string): GitFileChangeType {
    switch (status[0]) {
      case 'A': return 'added'
      case 'M': return 'modified'
      case 'D': return 'deleted'
      case 'R': return 'renamed'
      case '?': return 'untracked'
      default: return 'unknown'
    }
  }
}

interface GitStatus {
  files: GitFileStatus[]
}

interface GitFileStatus {
  path: string
  status: GitFileChangeType
  staged: boolean
  modified: boolean
}

type GitFileChangeType = 'added' | 'modified' | 'deleted' | 'renamed' | 'untracked' | 'unknown'
```

#### Docker é›†æˆ
```typescript
// services/docker-integration.ts
export class DockerIntegration {
  async buildImage(dockerfile: string, tag: string): Promise<BuildResult> {
    const buildCommand = `docker build -t ${tag} -f ${dockerfile} .`
    
    try {
      const output = await this.executeCommand(buildCommand)
      return { success: true, output }
    } catch (error) {
      return { success: false, error: error.message, output: '' }
    }
  }

  async runContainer(image: string, options: ContainerOptions): Promise<RunResult> {
    let command = `docker run`
    
    if (options.detach) command += ' -d'
    if (options.ports) {
      options.ports.forEach(port => {
        command += ` -p ${port.host}:${port.container}`
      })
    }
    if (options.volumes) {
      options.volumes.forEach(volume => {
        command += ` -v ${volume.host}:${volume.container}`
      })
    }
    if (options.environment) {
      Object.entries(options.environment).forEach(([key, value]) => {
        command += ` -e ${key}=${value}`
      })
    }
    
    command += ` ${image}`
    
    try {
      const output = await this.executeCommand(command)
      return { success: true, containerId: this.extractContainerId(output) }
    } catch (error) {
      return { success: false, error: error.message }
    }
  }

  async getContainerLogs(containerId: string): Promise<string> {
    return await this.executeCommand(`docker logs ${containerId}`)
  }

  async stopContainer(containerId: string): Promise<void> {
    await this.executeCommand(`docker stop ${containerId}`)
  }

  private async executeCommand(command: string): Promise<string> {
    // å®ç°å‘½ä»¤æ‰§è¡Œ
    throw new Error('Command execution not implemented')
  }

  private extractContainerId(output: string): string {
    // ä» docker run è¾“å‡ºä¸­æå–å®¹å™¨ID
    return output.trim()
  }
}

interface ContainerOptions {
  detach?: boolean
  ports?: Array<{ host: number; container: number }>
  volumes?: Array<{ host: string; container: string }>
  environment?: Record<string, string>
}

interface BuildResult {
  success: boolean
  output: string
  error?: string
}

interface RunResult {
  success: boolean
  containerId?: string
  error?: string
}
```

### 2. APIæ¥å£æ‰©å±•

#### RESTful API é›†æˆ
```typescript
// services/api-client.ts
export class APIClient {
  private baseUrl: string
  private headers: Record<string, string>

  constructor(baseUrl: string, defaultHeaders: Record<string, string> = {}) {
    this.baseUrl = baseUrl
    this.headers = {
      'Content-Type': 'application/json',
      ...defaultHeaders
    }
  }

  async get<T>(endpoint: string, params?: Record<string, any>): Promise<T> {
    const url = new URL(endpoint, this.baseUrl)
    
    if (params) {
      Object.entries(params).forEach(([key, value]) => {
        url.searchParams.append(key, String(value))
      })
    }

    const response = await fetch(url.toString(), {
      method: 'GET',
      headers: this.headers
    })

    if (!response.ok) {
      throw new Error(`API request failed: ${response.statusText}`)
    }

    return await response.json()
  }

  async post<T>(endpoint: string, data: any): Promise<T> {
    const response = await fetch(new URL(endpoint, this.baseUrl).toString(), {
      method: 'POST',
      headers: this.headers,
      body: JSON.stringify(data)
    })

    if (!response.ok) {
      throw new Error(`API request failed: ${response.statusText}`)
    }

    return await response.json()
  }

  async put<T>(endpoint: string, data: any): Promise<T> {
    const response = await fetch(new URL(endpoint, this.baseUrl).toString(), {
      method: 'PUT',
      headers: this.headers,
      body: JSON.stringify(data)
    })

    if (!response.ok) {
      throw new Error(`API request failed: ${response.statusText}`)
    }

    return await response.json()
  }

  async delete<T>(endpoint: string): Promise<T> {
    const response = await fetch(new URL(endpoint, this.baseUrl).toString(), {
      method: 'DELETE',
      headers: this.headers
    })

    if (!response.ok) {
      throw new Error(`API request failed: ${response.statusText}`)
    }

    return await response.json()
  }

  setAuthToken(token: string): void {
    this.headers['Authorization'] = `Bearer ${token}`
  }

  removeAuthToken(): void {
    delete this.headers['Authorization']
  }
}

// ä½¿ç”¨ç¤ºä¾‹
const githubAPI = new APIClient('https://api.github.com')

// GitHub é›†æˆ
export class GitHubIntegration {
  private client: APIClient

  constructor(token?: string) {
    this.client = new APIClient('https://api.github.com')
    if (token) {
      this.client.setAuthToken(token)
    }
  }

  async getRepositories(): Promise<Repository[]> {
    return await this.client.get<Repository[]>('/user/repos')
  }

  async createRepository(data: CreateRepoData): Promise<Repository> {
    return await this.client.post<Repository>('/user/repos', data)
  }

  async uploadFile(repo: string, path: string, content: string, message: string): Promise<void> {
    const data = {
      message,
      content: btoa(content), // Base64 ç¼–ç 
      branch: 'main'
    }

    await this.client.put(`/repos/${repo}/contents/${path}`, data)
  }

  async createGist(files: Record<string, { content: string }>, description?: string): Promise<Gist> {
    const data = {
      description: description || 'Created from Readdy Editor',
      public: false,
      files
    }

    return await this.client.post<Gist>('/gists', data)
  }
}

interface Repository {
  id: number
  name: string
  full_name: string
  private: boolean
  html_url: string
}

interface CreateRepoData {
  name: string
  description?: string
  private?: boolean
  auto_init?: boolean
}

interface Gist {
  id: string
  html_url: string
  files: Record<string, any>
}
```

### 3. æ•°æ®å¯¼å…¥å¯¼å‡ºæ‰©å±•

#### å¤šæ ¼å¼å¯¼å‡ºå™¨
```typescript
// services/export-manager.ts
export class ExportManager {
  private exporters = new Map<string, FileExporter>()

  register(exporter: FileExporter): void {
    this.exporters.set(exporter.format, exporter)
  }

  async export(content: string, format: string, options?: ExportOptions): Promise<ExportResult> {
    const exporter = this.exporters.get(format)
    if (!exporter) {
      throw new Error(`ä¸æ”¯æŒçš„å¯¼å‡ºæ ¼å¼: ${format}`)
    }

    return await exporter.export(content, options)
  }

  getSupportedFormats(): string[] {
    return Array.from(this.exporters.keys())
  }
}

export interface FileExporter {
  format: string
  name: string
  description: string
  fileExtension: string
  
  export(content: string, options?: ExportOptions): Promise<ExportResult>
}

export interface ExportOptions {
  filename?: string
  metadata?: Record<string, any>
  [key: string]: any
}

export interface ExportResult {
  success: boolean
  data?: Blob | string
  filename?: string
  error?: string
}

// PDF å¯¼å‡ºå™¨
export class PDFExporter implements FileExporter {
  format = 'pdf'
  name = 'PDF'
  description = 'å¯¼å‡ºä¸ºPDFæ–‡æ¡£'
  fileExtension = 'pdf'

  async export(content: string, options?: ExportOptions): Promise<ExportResult> {
    try {
      // ä½¿ç”¨ jsPDF æˆ–å…¶ä»–PDFåº“
      const { jsPDF } = await import('jspdf')
      const doc = new jsPDF()

      // å¤„ç†Markdownå†…å®¹
      const html = this.markdownToHTML(content)
      
      // æ·»åŠ å†…å®¹åˆ°PDF
      doc.html(html, {
        callback: (doc) => {
          const pdfBlob = doc.output('blob')
          return {
            success: true,
            data: pdfBlob,
            filename: options?.filename || 'document.pdf'
          }
        }
      })

      return { success: true }
    } catch (error) {
      return {
        success: false,
        error: `PDFå¯¼å‡ºå¤±è´¥: ${error.message}`
      }
    }
  }

  private markdownToHTML(markdown: string): string {
    // ç®€å•çš„Markdownè½¬HTML
    return markdown
      .replace(/^# (.*$)/gim, '<h1>$1</h1>')
      .replace(/^## (.*$)/gim, '<h2>$1</h2>')
      .replace(/^### (.*$)/gim, '<h3>$1</h3>')
      .replace(/\*\*(.*)\*\*/gim, '<strong>$1</strong>')
      .replace(/\*(.*)\*/gim, '<em>$1</em>')
      .replace(/\n/gim, '<br>')
  }
}

// Word å¯¼å‡ºå™¨
export class WordExporter implements FileExporter {
  format = 'docx'
  name = 'Wordæ–‡æ¡£'
  description = 'å¯¼å‡ºä¸ºMicrosoft Wordæ–‡æ¡£'
  fileExtension = 'docx'

  async export(content: string, options?: ExportOptions): Promise<ExportResult> {
    try {
      // ä½¿ç”¨ docx åº“
      const { Document, Packer, Paragraph, TextRun } = await import('docx')

      const doc = new Document({
        sections: [{
          properties: {},
          children: this.parseMarkdownToDocx(content)
        }]
      })

      const buffer = await Packer.toBuffer(doc)
      const blob = new Blob([buffer], { 
        type: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document' 
      })

      return {
        success: true,
        data: blob,
        filename: options?.filename || 'document.docx'
      }
    } catch (error) {
      return {
        success: false,
        error: `Wordå¯¼å‡ºå¤±è´¥: ${error.message}`
      }
    }
  }

  private parseMarkdownToDocx(markdown: string): any[] {
    // è§£æMarkdownå¹¶è½¬æ¢ä¸ºdocxæ ¼å¼
    const lines = markdown.split('\n')
    const paragraphs = []

    for (const line of lines) {
      if (line.startsWith('# ')) {
        paragraphs.push(new Paragraph({
          children: [new TextRun({ text: line.substring(2), bold: true, size: 32 })]
        }))
      } else if (line.startsWith('## ')) {
        paragraphs.push(new Paragraph({
          children: [new TextRun({ text: line.substring(3), bold: true, size: 28 })]
        }))
      } else {
        paragraphs.push(new Paragraph({
          children: [new TextRun(line)]
        }))
      }
    }

    return paragraphs
  }
}

// åˆå§‹åŒ–å¯¼å‡ºç®¡ç†å™¨
export const exportManager = new ExportManager()
exportManager.register(new PDFExporter())
exportManager.register(new WordExporter())
```

## ğŸ“š æ‰©å±•å¼€å‘æœ€ä½³å®è·µ

### 1. æ¨¡å—åŒ–è®¾è®¡åŸåˆ™

```typescript
// è‰¯å¥½çš„æ‰©å±•æ¨¡å—ç»“æ„
export interface ExtensionModule {
  // æ¨¡å—ä¿¡æ¯
  id: string
  name: string
  version: string
  description?: string
  
  // ä¾èµ–å£°æ˜
  dependencies?: string[]
  optionalDependencies?: string[]
  
  // ç”Ÿå‘½å‘¨æœŸé’©å­
  onInstall?(): Promise<void>
  onActivate?(): Promise<void>
  onDeactivate?(): Promise<void>
  onUninstall?(): Promise<void>
  
  // åŠŸèƒ½æä¾›
  provides?: string[]
  
  // é…ç½®é€‰é¡¹
  configuration?: ConfigurationSchema
}

interface ConfigurationSchema {
  properties: Record<string, ConfigProperty>
}

interface ConfigProperty {
  type: 'string' | 'number' | 'boolean' | 'object' | 'array'
  default?: any
  description?: string
  enum?: any[]
}
```

### 2. é”™è¯¯å¤„ç†å’Œæ—¥å¿—

```typescript
// services/logger.ts
export class Logger {
  private context: string

  constructor(context: string) {
    this.context = context
  }

  debug(message: string, data?: any): void {
    console.debug(`[${this.context}] ${message}`, data)
  }

  info(message: string, data?: any): void {
    console.info(`[${this.context}] ${message}`, data)
  }

  warn(message: string, data?: any): void {
    console.warn(`[${this.context}] ${message}`, data)
  }

  error(message: string, error?: Error, data?: any): void {
    console.error(`[${this.context}] ${message}`, error, data)
    
    // å‘é€åˆ°é”™è¯¯æ”¶é›†æœåŠ¡
    this.reportError(message, error, data)
  }

  private reportError(message: string, error?: Error, data?: any): void {
    // å®ç°é”™è¯¯ä¸ŠæŠ¥é€»è¾‘
  }
}

// åœ¨æ‰©å±•ä¸­ä½¿ç”¨
export class MyExtension {
  private logger = new Logger('MyExtension')

  async someMethod(): Promise<void> {
    try {
      this.logger.info('å¼€å§‹æ‰§è¡Œæ“ä½œ')
      // æ‰§è¡Œæ“ä½œ
      this.logger.info('æ“ä½œå®Œæˆ')
    } catch (error) {
      this.logger.error('æ“ä½œå¤±è´¥', error, { context: 'someMethod' })
      throw error
    }
  }
}
```

### 3. æµ‹è¯•æŒ‡å—

```typescript
// tests/extensions/my-extension.test.ts
import { describe, it, expect, beforeEach, afterEach } from 'vitest'
import { MyExtension } from '../../../src/extensions/my-extension'

describe('MyExtension', () => {
  let extension: MyExtension

  beforeEach(() => {
    extension = new MyExtension()
  })

  afterEach(() => {
    // æ¸…ç†
  })

  it('should initialize correctly', () => {
    expect(extension.id).toBe('my-extension')
    expect(extension.name).toBe('My Extension')
  })

  it('should handle file processing', async () => {
    const testContent = '# Test Document'
    const result = await extension.processFile(testContent)
    
    expect(result.success).toBe(true)
    expect(result.data).toContain('Test Document')
  })

  it('should handle errors gracefully', async () => {
    const invalidContent = null
    
    await expect(extension.processFile(invalidContent))
      .rejects.toThrow('Invalid content')
  })
})
```

### 4. æ€§èƒ½ä¼˜åŒ–å»ºè®®

```typescript
// ä½¿ç”¨æ‡’åŠ è½½
const LazyComponent = defineAsyncComponent(() => import('./HeavyComponent.vue'))

// ä½¿ç”¨é˜²æŠ–å¤„ç†é¢‘ç¹æ“ä½œ
import { debounce } from 'lodash-es'

const debouncedSearch = debounce(async (query: string) => {
  // æ‰§è¡Œæœç´¢
}, 300)

// ä½¿ç”¨ç¼“å­˜å‡å°‘é‡å¤è®¡ç®—
const cache = new Map<string, any>()

function expensiveOperation(input: string): any {
  if (cache.has(input)) {
    return cache.get(input)
  }

  const result = performCalculation(input)
  cache.set(input, result)
  return result
}

// ä½¿ç”¨Web Workerså¤„ç†é‡CPUä»»åŠ¡
const worker = new Worker('./heavy-computation.worker.ts')

worker.postMessage({ data: largeDataSet })
worker.onmessage = (event) => {
  const result = event.data
  // å¤„ç†ç»“æœ
}
```

## ğŸš€ æ‰©å±•å‘å¸ƒæŒ‡å—

### 1. æ‰©å±•æ‰“åŒ…

```bash
# æ‰“åŒ…æ‰©å±•
npm run build:extension

# ç”Ÿæˆæ‰©å±•åŒ…
npm run package:extension

# éªŒè¯æ‰©å±•åŒ…
npm run validate:extension
```

### 2. æ‰©å±•å¸‚åœº

```typescript
// extension-manifest.json
{
  "id": "my-awesome-extension",
  "name": "My Awesome Extension",
  "version": "1.0.0",
  "description": "An awesome extension for Readdy Editor",
  "author": "Your Name",
  "license": "MIT",
  "homepage": "https://github.com/yourname/my-awesome-extension",
  "repository": {
    "type": "git",
    "url": "https://github.com/yourname/my-awesome-extension.git"
  },
  "categories": ["Editor", "AI", "Tools"],
  "keywords": ["markdown", "ai", "productivity"],
  "engines": {
    "readdy": ">=1.0.0"
  },
  "activationEvents": [
    "onFileType:markdown",
    "onCommand:my-extension.activate"
  ],
  "main": "./dist/extension.js",
  "contributes": {
    "commands": [...],
    "fileTypes": [...],
    "themes": [...],
    "languages": [...]
  }
}
```

---

**æœ€åæ›´æ–°**: 2025-07-03  
**é€‚ç”¨ç‰ˆæœ¬**: Readdy Editor v1.0.0+  
**ç»´æŠ¤è€…**: Claude (Anthropic)

è¿™ä¸ªæ‰©å±•å¼€å‘æŒ‡å—ä¸ºå¼€å‘è€…æä¾›äº†å®Œæ•´çš„æ‰©å±•å¼€å‘æ¡†æ¶å’Œæœ€ä½³å®è·µï¼Œå¸®åŠ©å¿«é€Ÿæ„å»ºé«˜è´¨é‡çš„ç¼–è¾‘å™¨æ‰©å±•åŠŸèƒ½ã€‚