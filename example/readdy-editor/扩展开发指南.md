# Readdy Editor 扩展开发指南

## 📋 概述

本指南详细说明如何扩展 Readdy Editor 的功能，包括支持新的文件类型、编辑器功能、AI模型集成、UI组件等。通过模块化的架构设计，开发者可以轻松地为编辑器添加新功能而不影响现有系统。

## 🏗️ 扩展架构概览

### 扩展点分类
```
Readdy Editor 扩展系统
├── 文件类型扩展
│   ├── 语法高亮支持
│   ├── 文件图标定制
│   ├── 语言服务集成
│   └── 自定义渲染器
├── 编辑器功能扩展
│   ├── 编辑器插件
│   ├── 快捷键绑定
│   ├── 主题扩展
│   └── 工具栏定制
├── AI服务扩展
│   ├── 新AI提供商
│   ├── 自定义提示词
│   ├── 专业化AI助手
│   └── AI工作流
├── UI/UX扩展
│   ├── 新组件开发
│   ├── 布局模式
│   ├── 交互增强
│   └── 可访问性
└── 集成扩展
    ├── 外部工具集成
    ├── API接口
    ├── 插件系统
    └── 数据导入导出
```

## 📝 文件类型扩展

### 1. 基础文件类型支持

#### 添加新的文件类型识别
```typescript
// types/file-types.ts
export interface FileTypeDefinition {
  extension: string[]           // 文件扩展名
  name: string                 // 显示名称
  category: 'code' | 'markup' | 'data' | 'image' | 'document'
  icon: string                 // 图标类名
  monacoLanguage?: string      // Monaco语言ID
  defaultContent?: string      // 默认内容模板
  customRenderer?: boolean     // 是否需要自定义渲染器
}

// 内置文件类型定义
export const FILE_TYPES: Record<string, FileTypeDefinition> = {
  markdown: {
    extension: ['md', 'markdown'],
    name: 'Markdown',
    category: 'markup',
    icon: 'ri-markdown-fill',
    monacoLanguage: 'markdown',
    defaultContent: '# 新建文档\n\n开始编写内容...'
  },
  
  javascript: {
    extension: ['js', 'jsx'],
    name: 'JavaScript',
    category: 'code',
    icon: 'ri-javascript-fill',
    monacoLanguage: 'javascript',
    defaultContent: '// JavaScript 文件\nconsole.log("Hello World");'
  },

  python: {
    extension: ['py'],
    name: 'Python',
    category: 'code',
    icon: 'ri-code-s-slash-fill',
    monacoLanguage: 'python',
    defaultContent: '# Python 文件\nprint("Hello World")'
  },

  // 新增：支持更多类型
  rust: {
    extension: ['rs'],
    name: 'Rust',
    category: 'code',
    icon: 'ri-terminal-box-fill',
    monacoLanguage: 'rust',
    defaultContent: 'fn main() {\n    println!("Hello, world!");\n}'
  },

  vue: {
    extension: ['vue'],
    name: 'Vue Component',
    category: 'code',
    icon: 'ri-vuejs-fill',
    monacoLanguage: 'html',
    defaultContent: `<template>
  <div>
    <h1>{{ title }}</h1>
  </div>
</template>

<script setup lang="ts">
import { ref } from 'vue'

const title = ref('Vue Component')
</script>

<style scoped>
h1 {
  color: #42b883;
}
</style>`
  },

  json: {
    extension: ['json'],
    name: 'JSON',
    category: 'data',
    icon: 'ri-braces-fill',
    monacoLanguage: 'json',
    defaultContent: '{\n  "name": "example",\n  "version": "1.0.0"\n}'
  }
}
```

#### 文件类型注册系统
```typescript
// services/file-type-registry.ts
class FileTypeRegistry {
  private types = new Map<string, FileTypeDefinition>()

  // 注册新文件类型
  register(type: FileTypeDefinition): void {
    type.extension.forEach(ext => {
      this.types.set(ext.toLowerCase(), type)
    })
  }

  // 批量注册
  registerBatch(types: FileTypeDefinition[]): void {
    types.forEach(type => this.register(type))
  }

  // 获取文件类型
  getType(filename: string): FileTypeDefinition | null {
    const ext = this.getExtension(filename)
    return this.types.get(ext) || null
  }

  // 获取所有支持的类型
  getAllTypes(): FileTypeDefinition[] {
    return Array.from(new Set(this.types.values()))
  }

  // 按分类获取类型
  getTypesByCategory(category: string): FileTypeDefinition[] {
    return this.getAllTypes().filter(type => type.category === category)
  }

  private getExtension(filename: string): string {
    return filename.split('.').pop()?.toLowerCase() || ''
  }
}

export const fileTypeRegistry = new FileTypeRegistry()

// 初始化内置类型
fileTypeRegistry.registerBatch(Object.values(FILE_TYPES))
```

### 2. Monaco Editor 语言支持扩展

#### 自定义语言支持
```typescript
// services/language-support.ts
import * as monaco from 'monaco-editor'

export class LanguageSupportService {
  // 注册自定义语言
  static registerCustomLanguage(languageId: string, config: {
    extensions: string[]
    aliases: string[]
    mimetypes?: string[]
    tokenizer?: any
    languageConfiguration?: any
  }): void {
    // 注册语言
    monaco.languages.register({
      id: languageId,
      extensions: config.extensions,
      aliases: config.aliases,
      mimetypes: config.mimetypes
    })

    // 设置语言配置
    if (config.languageConfiguration) {
      monaco.languages.setLanguageConfiguration(languageId, config.languageConfiguration)
    }

    // 设置词法分析器
    if (config.tokenizer) {
      monaco.languages.setMonarchTokensProvider(languageId, config.tokenizer)
    }
  }

  // MDX 支持示例
  static registerMDX(): void {
    this.registerCustomLanguage('mdx', {
      extensions: ['.mdx'],
      aliases: ['MDX', 'mdx'],
      tokenizer: {
        root: [
          // JSX 语法
          [/<\/?[a-zA-Z][\w\-]*/, 'tag'],
          [/{[^}]*}/, 'delimiter.bracket'],
          
          // Markdown 语法
          [/^#.*$/, 'header'],
          [/\*\*.*?\*\*/, 'strong'],
          [/\*.*?\*/, 'emphasis'],
          [/`.*?`/, 'code'],
          
          // 其他标记
          [/.*/, 'text']
        ]
      },
      languageConfiguration: {
        comments: {
          blockComment: ['{/*', '*/}']
        },
        brackets: [
          ['{', '}'],
          ['[', ']'],
          ['(', ')']
        ],
        autoClosingPairs: [
          { open: '{', close: '}' },
          { open: '[', close: ']' },
          { open: '(', close: ')' },
          { open: '"', close: '"' },
          { open: "'", close: "'" }
        ]
      }
    })
  }

  // YAML 支持增强
  static registerEnhancedYAML(): void {
    // 添加 YAML 特定的智能提示
    monaco.languages.registerCompletionItemProvider('yaml', {
      provideCompletionItems: (model, position) => {
        const suggestions = [
          {
            label: 'apiVersion',
            kind: monaco.languages.CompletionItemKind.Property,
            insertText: 'apiVersion: ',
            documentation: 'API version'
          },
          {
            label: 'kind',
            kind: monaco.languages.CompletionItemKind.Property,
            insertText: 'kind: ',
            documentation: 'Resource kind'
          }
        ]
        return { suggestions }
      }
    })
  }

  // SQL 支持
  static registerSQL(): void {
    this.registerCustomLanguage('sql', {
      extensions: ['.sql'],
      aliases: ['SQL', 'sql'],
      tokenizer: {
        root: [
          // SQL 关键字
          [/\b(SELECT|FROM|WHERE|INSERT|UPDATE|DELETE|CREATE|DROP|ALTER|TABLE)\b/i, 'keyword'],
          
          // 函数
          [/\b(COUNT|SUM|AVG|MAX|MIN|DISTINCT)\b/i, 'function'],
          
          // 字符串
          [/'([^'\\]|\\.)*'/, 'string'],
          [/"([^"\\]|\\.)*"/, 'string'],
          
          // 数字
          [/\d+/, 'number'],
          
          // 注释
          [/--.*$/, 'comment'],
          [/\/\*[\s\S]*?\*\//, 'comment']
        ]
      }
    })
  }
}

// 初始化语言支持
LanguageSupportService.registerMDX()
LanguageSupportService.registerEnhancedYAML()
LanguageSupportService.registerSQL()
```

### 3. 自定义文件渲染器

#### 渲染器接口定义
```typescript
// types/renderer.ts
export interface FileRenderer {
  // 渲染器ID
  id: string
  
  // 支持的文件类型
  supportedTypes: string[]
  
  // 渲染文件内容
  render(content: string, metadata?: any): Promise<RenderedContent>
  
  // 是否支持实时预览
  supportsLivePreview: boolean
  
  // 获取工具栏按钮
  getToolbarButtons?(): ToolbarButton[]
}

export interface RenderedContent {
  html: string
  css?: string
  scripts?: string[]
  interactive?: boolean
}

export interface ToolbarButton {
  id: string
  label: string
  icon: string
  action: () => void
}
```

#### Markdown 渲染器实现
```typescript
// renderers/markdown-renderer.ts
import MarkdownIt from 'markdown-it'
import hljs from 'highlight.js'

export class MarkdownRenderer implements FileRenderer {
  id = 'markdown'
  supportedTypes = ['md', 'markdown']
  supportsLivePreview = true

  private md: MarkdownIt

  constructor() {
    this.md = new MarkdownIt({
      html: true,
      highlight: (str, lang) => {
        if (lang && hljs.getLanguage(lang)) {
          try {
            return hljs.highlight(str, { language: lang }).value
          } catch (__) {}
        }
        return ''
      }
    })

    // 添加插件
    this.md.use(require('markdown-it-footnote'))
    this.md.use(require('markdown-it-task-lists'))
    this.md.use(require('markdown-it-emoji'))
  }

  async render(content: string): Promise<RenderedContent> {
    const html = this.md.render(content)
    
    return {
      html,
      css: `
        .markdown-body {
          max-width: none;
          padding: 20px;
        }
        .markdown-body pre {
          background: #f6f8fa;
          padding: 16px;
          border-radius: 6px;
        }
        .markdown-body code {
          background: #f6f8fa;
          padding: 2px 4px;
          border-radius: 3px;
        }
      `,
      interactive: false
    }
  }

  getToolbarButtons(): ToolbarButton[] {
    return [
      {
        id: 'bold',
        label: '加粗',
        icon: 'ri-bold',
        action: () => this.insertFormat('**', '**')
      },
      {
        id: 'italic',
        label: '斜体',
        icon: 'ri-italic',
        action: () => this.insertFormat('*', '*')
      },
      {
        id: 'code',
        label: '代码',
        icon: 'ri-code-line',
        action: () => this.insertFormat('`', '`')
      },
      {
        id: 'link',
        label: '链接',
        icon: 'ri-link',
        action: () => this.insertFormat('[', '](url)')
      }
    ]
  }

  private insertFormat(before: string, after: string): void {
    // 在编辑器中插入格式化文本
    const editor = getCurrentEditor()
    if (editor) {
      const selection = editor.getSelection()
      const selectedText = editor.getModel()?.getValueInRange(selection) || ''
      const newText = `${before}${selectedText}${after}`
      
      editor.executeEdits('markdown-format', [{
        range: selection,
        text: newText
      }])
    }
  }
}
```

#### 图片预览渲染器
```typescript
// renderers/image-renderer.ts
export class ImageRenderer implements FileRenderer {
  id = 'image'
  supportedTypes = ['jpg', 'jpeg', 'png', 'gif', 'svg', 'webp']
  supportsLivePreview = false

  async render(content: string, metadata?: { filePath?: string }): Promise<RenderedContent> {
    const imageSrc = metadata?.filePath || `data:image/png;base64,${content}`
    
    const html = `
      <div class="image-viewer">
        <div class="image-container">
          <img src="${imageSrc}" alt="图片预览" />
        </div>
        <div class="image-info">
          <div class="image-actions">
            <button class="zoom-in">放大</button>
            <button class="zoom-out">缩小</button>
            <button class="reset-zoom">重置</button>
            <button class="download">下载</button>
          </div>
        </div>
      </div>
    `

    const css = `
      .image-viewer {
        display: flex;
        flex-direction: column;
        height: 100%;
        background: #f5f5f5;
      }
      .image-container {
        flex: 1;
        display: flex;
        justify-content: center;
        align-items: center;
        overflow: auto;
        padding: 20px;
      }
      .image-container img {
        max-width: 100%;
        max-height: 100%;
        transition: transform 0.3s ease;
        box-shadow: 0 4px 8px rgba(0,0,0,0.1);
      }
      .image-actions {
        display: flex;
        gap: 10px;
        padding: 15px;
        background: white;
        border-top: 1px solid #ddd;
      }
      .image-actions button {
        padding: 8px 16px;
        border: 1px solid #ddd;
        border-radius: 4px;
        background: white;
        cursor: pointer;
      }
    `

    const scripts = [`
      function initImageViewer() {
        let scale = 1;
        const img = document.querySelector('.image-container img');
        
        document.querySelector('.zoom-in').onclick = () => {
          scale *= 1.2;
          img.style.transform = \`scale(\${scale})\`;
        };
        
        document.querySelector('.zoom-out').onclick = () => {
          scale /= 1.2;
          img.style.transform = \`scale(\${scale})\`;
        };
        
        document.querySelector('.reset-zoom').onclick = () => {
          scale = 1;
          img.style.transform = 'scale(1)';
        };
      }
      
      initImageViewer();
    `]

    return { html, css, scripts, interactive: true }
  }
}
```

### 4. 渲染器注册系统

```typescript
// services/renderer-registry.ts
class RendererRegistry {
  private renderers = new Map<string, FileRenderer>()

  register(renderer: FileRenderer): void {
    this.renderers.set(renderer.id, renderer)
  }

  getRenderer(fileExtension: string): FileRenderer | null {
    for (const renderer of this.renderers.values()) {
      if (renderer.supportedTypes.includes(fileExtension)) {
        return renderer
      }
    }
    return null
  }

  getAllRenderers(): FileRenderer[] {
    return Array.from(this.renderers.values())
  }
}

export const rendererRegistry = new RendererRegistry()

// 注册内置渲染器
rendererRegistry.register(new MarkdownRenderer())
rendererRegistry.register(new ImageRenderer())
```

## 🔧 编辑器功能扩展

### 1. 编辑器插件系统

#### 插件接口定义
```typescript
// types/plugin.ts
export interface EditorPlugin {
  id: string
  name: string
  version: string
  description?: string
  
  // 插件生命周期
  onLoad?(editor: monaco.editor.IStandaloneCodeEditor): void
  onUnload?(editor: monaco.editor.IStandaloneCodeEditor): void
  
  // 编辑器事件
  onContentChange?(content: string): void
  onSelectionChange?(selection: monaco.Selection): void
  onCursorPositionChange?(position: monaco.Position): void
  
  // 命令注册
  commands?: EditorCommand[]
  
  // 快捷键绑定
  keybindings?: KeyBinding[]
  
  // UI 扩展
  toolbarButtons?: ToolbarButton[]
  contextMenuItems?: ContextMenuItem[]
}

export interface EditorCommand {
  id: string
  label: string
  execute: (editor: monaco.editor.IStandaloneCodeEditor, ...args: any[]) => void
}

export interface KeyBinding {
  key: string
  command: string
  when?: string
}

export interface ContextMenuItem {
  id: string
  label: string
  group?: string
  order?: number
  execute: (editor: monaco.editor.IStandaloneCodeEditor) => void
}
```

#### 自动格式化插件示例
```typescript
// plugins/auto-format-plugin.ts
export class AutoFormatPlugin implements EditorPlugin {
  id = 'auto-format'
  name = '自动格式化'
  version = '1.0.0'
  description = '保存时自动格式化代码'

  private editor?: monaco.editor.IStandaloneCodeEditor

  onLoad(editor: monaco.editor.IStandaloneCodeEditor): void {
    this.editor = editor
    
    // 监听保存事件
    editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.KeyS, () => {
      this.formatAndSave()
    })
  }

  onUnload(): void {
    this.editor = undefined
  }

  commands: EditorCommand[] = [
    {
      id: 'format-document',
      label: '格式化文档',
      execute: (editor) => {
        editor.getAction('editor.action.formatDocument')?.run()
      }
    }
  ]

  keybindings: KeyBinding[] = [
    {
      key: 'Shift+Alt+F',
      command: 'format-document'
    }
  ]

  toolbarButtons: ToolbarButton[] = [
    {
      id: 'format',
      label: '格式化',
      icon: 'ri-code-box-line',
      action: () => {
        this.editor?.getAction('editor.action.formatDocument')?.run()
      }
    }
  ]

  private async formatAndSave(): void {
    if (!this.editor) return
    
    // 先格式化
    await this.editor.getAction('editor.action.formatDocument')?.run()
    
    // 再保存
    const saveEvent = new CustomEvent('editor-save', {
      detail: { content: this.editor.getValue() }
    })
    document.dispatchEvent(saveEvent)
  }
}
```

#### 代码片段插件
```typescript
// plugins/snippet-plugin.ts
export class SnippetPlugin implements EditorPlugin {
  id = 'snippets'
  name = '代码片段'
  version = '1.0.0'

  private snippets: Record<string, CodeSnippet> = {
    'vue-component': {
      prefix: 'vcomp',
      body: [
        '<template>',
        '  <div>',
        '    $1',
        '  </div>',
        '</template>',
        '',
        '<script setup lang="ts">',
        '$2',
        '</script>',
        '',
        '<style scoped>',
        '$3',
        '</style>'
      ],
      description: 'Vue 3 组件模板'
    },
    
    'function': {
      prefix: 'fn',
      body: [
        'function ${1:functionName}(${2:params}) {',
        '  $3',
        '  return $4',
        '}'
      ],
      description: 'JavaScript 函数'
    }
  }

  onLoad(editor: monaco.editor.IStandaloneCodeEditor): void {
    // 注册代码片段
    Object.entries(this.snippets).forEach(([key, snippet]) => {
      monaco.languages.registerCompletionItemProvider('*', {
        provideCompletionItems: (model, position) => {
          const word = model.getWordUntilPosition(position)
          const range = {
            startLineNumber: position.lineNumber,
            endLineNumber: position.lineNumber,
            startColumn: word.startColumn,
            endColumn: word.endColumn
          }

          if (word.word === snippet.prefix) {
            return {
              suggestions: [{
                label: snippet.prefix,
                kind: monaco.languages.CompletionItemKind.Snippet,
                documentation: snippet.description,
                insertText: snippet.body.join('\n'),
                insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
                range
              }]
            }
          }
          return { suggestions: [] }
        }
      })
    })
  }

  commands: EditorCommand[] = [
    {
      id: 'insert-snippet',
      label: '插入代码片段',
      execute: (editor) => {
        this.showSnippetPicker(editor)
      }
    }
  ]

  private showSnippetPicker(editor: monaco.editor.IStandaloneCodeEditor): void {
    // 显示代码片段选择器
    const picker = document.createElement('div')
    picker.className = 'snippet-picker'
    picker.innerHTML = `
      <div class="snippet-list">
        ${Object.entries(this.snippets).map(([key, snippet]) => `
          <div class="snippet-item" data-key="${key}">
            <div class="snippet-prefix">${snippet.prefix}</div>
            <div class="snippet-description">${snippet.description}</div>
          </div>
        `).join('')}
      </div>
    `

    picker.addEventListener('click', (e) => {
      const item = (e.target as Element).closest('.snippet-item')
      if (item) {
        const key = item.getAttribute('data-key')!
        const snippet = this.snippets[key]
        
        const position = editor.getPosition()!
        editor.executeEdits('insert-snippet', [{
          range: new monaco.Range(position.lineNumber, position.column, position.lineNumber, position.column),
          text: snippet.body.join('\n')
        }])
        
        picker.remove()
      }
    })

    document.body.appendChild(picker)
  }
}

interface CodeSnippet {
  prefix: string
  body: string[]
  description: string
}
```

### 2. 主题扩展系统

#### 主题定义接口
```typescript
// types/theme.ts
export interface EditorTheme {
  id: string
  name: string
  type: 'light' | 'dark'
  
  // Monaco 主题定义
  monacoTheme: monaco.editor.IStandaloneThemeData
  
  // UI 主题变量
  uiColors: {
    primary: string
    background: string
    surface: string
    text: string
    textSecondary: string
    border: string
    hover: string
    active: string
  }
  
  // 自定义 CSS 变量
  cssVariables?: Record<string, string>
}
```

#### 自定义主题示例
```typescript
// themes/custom-themes.ts
export const draculaTheme: EditorTheme = {
  id: 'dracula',
  name: 'Dracula',
  type: 'dark',
  
  monacoTheme: {
    base: 'vs-dark',
    inherit: true,
    rules: [
      { token: 'comment', foreground: '6272a4', fontStyle: 'italic' },
      { token: 'keyword', foreground: 'ff79c6' },
      { token: 'string', foreground: 'f1fa8c' },
      { token: 'number', foreground: 'bd93f9' },
      { token: 'function', foreground: '50fa7b' },
      { token: 'class', foreground: '8be9fd' }
    ],
    colors: {
      'editor.background': '#282a36',
      'editor.foreground': '#f8f8f2',
      'editor.lineHighlightBackground': '#44475a',
      'editor.selectionBackground': '#44475a',
      'editorCursor.foreground': '#f8f8f0',
      'editorWhitespace.foreground': '#6272a4'
    }
  },
  
  uiColors: {
    primary: '#bd93f9',
    background: '#282a36',
    surface: '#44475a',
    text: '#f8f8f2',
    textSecondary: '#6272a4',
    border: '#6272a4',
    hover: '#44475a',
    active: '#bd93f9'
  },
  
  cssVariables: {
    '--sidebar-bg': '#21222c',
    '--toolbar-bg': '#191a21',
    '--button-hover': '#44475a'
  }
}

export const githubLightTheme: EditorTheme = {
  id: 'github-light',
  name: 'GitHub Light',
  type: 'light',
  
  monacoTheme: {
    base: 'vs',
    inherit: true,
    rules: [
      { token: 'comment', foreground: '6a737d', fontStyle: 'italic' },
      { token: 'keyword', foreground: 'd73a49' },
      { token: 'string', foreground: '032f62' },
      { token: 'number', foreground: '005cc5' },
      { token: 'function', foreground: '6f42c1' }
    ],
    colors: {
      'editor.background': '#ffffff',
      'editor.foreground': '#24292e',
      'editor.lineHighlightBackground': '#f6f8fa',
      'editor.selectionBackground': '#c8e1ff'
    }
  },
  
  uiColors: {
    primary: '#0366d6',
    background: '#ffffff',
    surface: '#f6f8fa',
    text: '#24292e',
    textSecondary: '#586069',
    border: '#e1e4e8',
    hover: '#f6f8fa',
    active: '#0366d6'
  }
}
```

#### 主题管理器
```typescript
// services/theme-manager.ts
class ThemeManager {
  private themes = new Map<string, EditorTheme>()
  private currentTheme: EditorTheme | null = null

  register(theme: EditorTheme): void {
    this.themes.set(theme.id, theme)
    
    // 注册 Monaco 主题
    monaco.editor.defineTheme(theme.id, theme.monacoTheme)
  }

  setTheme(themeId: string): void {
    const theme = this.themes.get(themeId)
    if (!theme) return
    
    this.currentTheme = theme
    
    // 应用 Monaco 主题
    monaco.editor.setTheme(themeId)
    
    // 应用 UI 主题
    this.applyUITheme(theme)
    
    // 保存主题偏好
    localStorage.setItem('editor-theme', themeId)
  }

  private applyUITheme(theme: EditorTheme): void {
    const root = document.documentElement
    
    // 应用 UI 颜色
    Object.entries(theme.uiColors).forEach(([key, value]) => {
      root.style.setProperty(`--color-${key}`, value)
    })
    
    // 应用自定义 CSS 变量
    if (theme.cssVariables) {
      Object.entries(theme.cssVariables).forEach(([key, value]) => {
        root.style.setProperty(key, value)
      })
    }
    
    // 设置主题类型
    root.setAttribute('data-theme', theme.type)
  }

  getCurrentTheme(): EditorTheme | null {
    return this.currentTheme
  }

  getAllThemes(): EditorTheme[] {
    return Array.from(this.themes.values())
  }

  // 从偏好设置中恢复主题
  restoreTheme(): void {
    const savedTheme = localStorage.getItem('editor-theme')
    if (savedTheme && this.themes.has(savedTheme)) {
      this.setTheme(savedTheme)
    }
  }
}

export const themeManager = new ThemeManager()

// 注册内置主题
themeManager.register(draculaTheme)
themeManager.register(githubLightTheme)
```

## 🤖 AI服务扩展

### 1. 新AI提供商集成

#### OpenAI 服务实现
```typescript
// services/ai/openai.ts
import { AIServiceBase } from './base'

export class OpenAIService extends AIServiceBase {
  constructor(config: AIConfig) {
    super(config)
  }

  async chat(messages: ChatMessage[]): Promise<string> {
    try {
      const response = await fetch('https://api.openai.com/v1/chat/completions', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${this.config.apiKey}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          model: this.config.model || 'gpt-3.5-turbo',
          messages: messages,
          temperature: 0.7,
          max_tokens: 2000
        })
      })

      const data = await response.json()
      
      if (!response.ok) {
        throw new Error(data.error?.message || 'OpenAI API 请求失败')
      }

      return data.choices[0].message.content
    } catch (error) {
      console.error('OpenAI 服务错误:', error)
      throw error
    }
  }

  async streamChat(
    messages: ChatMessage[], 
    onChunk: (chunk: StreamChunk) => void
  ): Promise<void> {
    try {
      const response = await fetch('https://api.openai.com/v1/chat/completions', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${this.config.apiKey}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          model: this.config.model || 'gpt-3.5-turbo',
          messages: messages,
          temperature: 0.7,
          max_tokens: 2000,
          stream: true
        })
      })

      const reader = response.body?.getReader()
      if (!reader) throw new Error('无法读取响应流')

      const decoder = new TextDecoder()

      while (true) {
        const { done, value } = await reader.read()
        if (done) break

        const chunk = decoder.decode(value)
        const lines = chunk.split('\n')

        for (const line of lines) {
          if (line.startsWith('data: ')) {
            const data = line.slice(6)
            if (data === '[DONE]') continue

            try {
              const parsed = JSON.parse(data)
              const content = parsed.choices[0]?.delta?.content
              
              if (content) {
                onChunk({ content, finished: false })
              }
            } catch (e) {
              // 忽略解析错误
            }
          }
        }
      }

      onChunk({ content: '', finished: true })
    } catch (error) {
      console.error('OpenAI 流式请求错误:', error)
      throw error
    }
  }

  isConfigured(): boolean {
    return !!(this.config.apiKey && this.config.apiKey.length > 0)
  }
}
```

#### Claude 服务实现
```typescript
// services/ai/claude.ts
export class ClaudeService extends AIServiceBase {
  async chat(messages: ChatMessage[]): Promise<string> {
    try {
      const response = await fetch('https://api.anthropic.com/v1/messages', {
        method: 'POST',
        headers: {
          'x-api-key': this.config.apiKey!,
          'Content-Type': 'application/json',
          'anthropic-version': '2023-06-01'
        },
        body: JSON.stringify({
          model: this.config.model || 'claude-3-sonnet-20240229',
          max_tokens: 2000,
          messages: messages
        })
      })

      const data = await response.json()
      
      if (!response.ok) {
        throw new Error(data.error?.message || 'Claude API 请求失败')
      }

      return data.content[0].text
    } catch (error) {
      console.error('Claude 服务错误:', error)
      throw error
    }
  }

  // 实现其他必需方法...
}
```

### 2. 专业化AI助手

#### 代码审查助手
```typescript
// services/ai/code-reviewer.ts
export class CodeReviewerAI {
  constructor(private aiService: AIServiceBase) {}

  async reviewCode(code: string, language: string): Promise<CodeReviewResult> {
    const prompt = `作为一个资深的${language}开发者，请审查以下代码：

\`\`\`${language}
${code}
\`\`\`

请从以下方面进行分析：
1. 代码质量和最佳实践
2. 潜在的bug和安全问题
3. 性能优化建议
4. 代码可读性和维护性
5. 具体的改进建议

请以JSON格式返回结果：
{
  "score": 85,
  "issues": [...],
  "suggestions": [...],
  "improvements": "..."
}`

    try {
      const response = await this.aiService.chat([
        { role: 'user', content: prompt }
      ])

      return JSON.parse(response)
    } catch (error) {
      console.error('代码审查失败:', error)
      throw error
    }
  }
}

interface CodeReviewResult {
  score: number
  issues: CodeIssue[]
  suggestions: string[]
  improvements: string
}

interface CodeIssue {
  type: 'bug' | 'security' | 'performance' | 'style'
  severity: 'low' | 'medium' | 'high'
  line?: number
  message: string
  suggestion?: string
}
```

#### 文档生成助手
```typescript
// services/ai/doc-generator.ts
export class DocumentationAI {
  constructor(private aiService: AIServiceBase) {}

  async generateAPIDoc(code: string): Promise<string> {
    const prompt = `请为以下代码生成API文档：

${code}

要求：
1. 使用Markdown格式
2. 包含函数/方法的描述
3. 列出参数和返回值
4. 提供使用示例
5. 注明可能的异常情况`

    return await this.aiService.chat([
      { role: 'user', content: prompt }
    ])
  }

  async generateReadme(projectInfo: ProjectInfo): Promise<string> {
    const prompt = `请为以下项目生成README.md文档：

项目名称: ${projectInfo.name}
项目描述: ${projectInfo.description}
技术栈: ${projectInfo.technologies.join(', ')}
主要功能: ${projectInfo.features.join(', ')}

要求包含：
1. 项目简介
2. 功能特性
3. 安装说明
4. 使用指南
5. API文档
6. 贡献指南
7. 许可证信息`

    return await this.aiService.chat([
      { role: 'user', content: prompt }
    ])
  }
}

interface ProjectInfo {
  name: string
  description: string
  technologies: string[]
  features: string[]
}
```

### 3. AI工作流引擎

#### 工作流定义
```typescript
// types/workflow.ts
export interface AIWorkflow {
  id: string
  name: string
  description: string
  steps: WorkflowStep[]
  triggers: WorkflowTrigger[]
}

export interface WorkflowStep {
  id: string
  type: 'ai-chat' | 'transform' | 'validate' | 'save'
  config: any
  nextSteps?: string[]
}

export interface WorkflowTrigger {
  type: 'file-save' | 'text-selection' | 'manual'
  conditions?: any
}
```

#### 工作流示例
```typescript
// workflows/code-optimization.ts
export const codeOptimizationWorkflow: AIWorkflow = {
  id: 'code-optimization',
  name: '代码优化工作流',
  description: '自动分析和优化代码',
  
  triggers: [
    {
      type: 'file-save',
      conditions: { fileType: ['js', 'ts', 'py'] }
    }
  ],
  
  steps: [
    {
      id: 'analyze-code',
      type: 'ai-chat',
      config: {
        prompt: '分析以下代码的性能问题：{content}',
        aiService: 'openai'
      },
      nextSteps: ['suggest-optimizations']
    },
    {
      id: 'suggest-optimizations',
      type: 'ai-chat',
      config: {
        prompt: '基于分析结果，提供具体的优化建议：{analysis}',
        aiService: 'claude'
      },
      nextSteps: ['apply-optimizations']
    },
    {
      id: 'apply-optimizations',
      type: 'transform',
      config: {
        action: 'show-suggestions-panel'
      }
    }
  ]
}
```

## 🎨 UI/UX扩展

### 1. 自定义组件开发

#### 组件接口规范
```typescript
// types/component.ts
export interface CustomComponent {
  name: string
  props: ComponentProps
  emits: ComponentEmits
  slots?: ComponentSlots
  
  // 组件元数据
  category: 'editor' | 'sidebar' | 'toolbar' | 'modal'
  version: string
  dependencies?: string[]
}

export interface ComponentProps {
  [key: string]: {
    type: 'string' | 'number' | 'boolean' | 'object' | 'array'
    required?: boolean
    default?: any
    description?: string
  }
}

export interface ComponentEmits {
  [key: string]: {
    payload?: any
    description?: string
  }
}

export interface ComponentSlots {
  [key: string]: {
    props?: any
    description?: string
  }
}
```

#### 高级搜索组件示例
```vue
<!-- components/advanced-search/AdvancedSearch.vue -->
<template>
  <div class="advanced-search">
    <div class="search-header">
      <input
        v-model="searchQuery"
        class="search-input"
        placeholder="搜索文件和内容..."
        @input="handleSearch"
      />
      <button
        class="filter-toggle"
        @click="showFilters = !showFilters"
      >
        <i class="ri-filter-line"></i>
      </button>
    </div>

    <div v-if="showFilters" class="search-filters">
      <div class="filter-group">
        <label>文件类型</label>
        <div class="filter-options">
          <label v-for="type in fileTypes" :key="type">
            <input
              v-model="selectedTypes"
              type="checkbox"
              :value="type"
            />
            {{ type }}
          </label>
        </div>
      </div>

      <div class="filter-group">
        <label>修改时间</label>
        <select v-model="timeFilter">
          <option value="">全部</option>
          <option value="today">今天</option>
          <option value="week">本周</option>
          <option value="month">本月</option>
        </select>
      </div>

      <div class="filter-group">
        <label>文件大小</label>
        <div class="size-range">
          <input
            v-model="sizeMin"
            type="number"
            placeholder="最小(KB)"
          />
          <span>-</span>
          <input
            v-model="sizeMax"
            type="number"
            placeholder="最大(KB)"
          />
        </div>
      </div>
    </div>

    <div class="search-results">
      <div
        v-for="result in searchResults"
        :key="result.id"
        class="search-result-item"
        @click="openFile(result.id)"
      >
        <div class="result-icon">
          <i :class="getFileIcon(result)"></i>
        </div>
        <div class="result-content">
          <div class="result-title">{{ result.name }}</div>
          <div class="result-path">{{ result.path }}</div>
          <div v-if="result.preview" class="result-preview">
            {{ result.preview }}
          </div>
        </div>
        <div class="result-meta">
          <span class="result-size">{{ formatSize(result.size) }}</span>
          <span class="result-date">{{ formatDate(result.updatedAt) }}</span>
        </div>
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, computed, watch } from 'vue'
import { fileSystem } from '@/services/file-system'
import type { FileEntry } from '@/types'

// Props
const props = defineProps<{
  files: FileEntry[]
}>()

// Emits
const emit = defineEmits<{
  'file-select': [fileId: string]
  'search-change': [query: string, filters: SearchFilters]
}>()

// 搜索状态
const searchQuery = ref('')
const showFilters = ref(false)
const selectedTypes = ref<string[]>([])
const timeFilter = ref('')
const sizeMin = ref<number>()
const sizeMax = ref<number>()

// 搜索结果
const searchResults = ref<SearchResult[]>([])

// 文件类型列表
const fileTypes = computed(() => {
  const types = new Set<string>()
  props.files.forEach(file => {
    const ext = file.name.split('.').pop()
    if (ext) types.add(ext)
  })
  return Array.from(types)
})

// 搜索逻辑
const handleSearch = async () => {
  const filters: SearchFilters = {
    types: selectedTypes.value,
    timeFilter: timeFilter.value,
    sizeRange: {
      min: sizeMin.value,
      max: sizeMax.value
    }
  }

  emit('search-change', searchQuery.value, filters)

  // 执行搜索
  searchResults.value = await performSearch(searchQuery.value, filters)
}

const performSearch = async (query: string, filters: SearchFilters): Promise<SearchResult[]> => {
  let results = props.files

  // 文本搜索
  if (query) {
    results = results.filter(file => 
      file.name.toLowerCase().includes(query.toLowerCase()) ||
      file.content.toLowerCase().includes(query.toLowerCase())
    )
  }

  // 类型过滤
  if (filters.types.length > 0) {
    results = results.filter(file => {
      const ext = file.name.split('.').pop()
      return ext && filters.types.includes(ext)
    })
  }

  // 时间过滤
  if (filters.timeFilter) {
    const now = new Date()
    const filterDate = getFilterDate(filters.timeFilter, now)
    results = results.filter(file => file.updatedAt >= filterDate)
  }

  // 大小过滤
  if (filters.sizeRange.min || filters.sizeRange.max) {
    results = results.filter(file => {
      const size = (file.size || 0) / 1024 // 转换为KB
      if (filters.sizeRange.min && size < filters.sizeRange.min) return false
      if (filters.sizeRange.max && size > filters.sizeRange.max) return false
      return true
    })
  }

  // 生成搜索结果
  return results.map(file => ({
    id: file.id,
    name: file.name,
    path: getFilePath(file),
    size: file.size || 0,
    updatedAt: file.updatedAt,
    preview: getContentPreview(file.content, query)
  }))
}

// 工具函数
const openFile = (fileId: string) => {
  emit('file-select', fileId)
}

const getFileIcon = (result: SearchResult) => {
  const ext = result.name.split('.').pop()?.toLowerCase()
  // 返回对应的图标类名
  return `ri-file-${ext || 'text'}-line`
}

const formatSize = (bytes: number) => {
  if (bytes === 0) return '0 B'
  const k = 1024
  const sizes = ['B', 'KB', 'MB', 'GB']
  const i = Math.floor(Math.log(bytes) / Math.log(k))
  return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i]
}

const formatDate = (date: Date) => {
  return new Intl.RelativeTimeFormatter('zh', { numeric: 'auto' })
    .format(Math.floor((date.getTime() - Date.now()) / (1000 * 60 * 60 * 24)), 'day')
}

// 监听搜索变化
watch([searchQuery, selectedTypes, timeFilter, sizeMin, sizeMax], handleSearch, { 
  deep: true 
})

// 类型定义
interface SearchFilters {
  types: string[]
  timeFilter: string
  sizeRange: {
    min?: number
    max?: number
  }
}

interface SearchResult {
  id: string
  name: string
  path: string
  size: number
  updatedAt: Date
  preview?: string
}
</script>

<style scoped>
.advanced-search {
  display: flex;
  flex-direction: column;
  height: 100%;
}

.search-header {
  display: flex;
  gap: 8px;
  padding: 12px;
  border-bottom: 1px solid var(--color-border);
}

.search-input {
  flex: 1;
  padding: 8px 12px;
  border: 1px solid var(--color-border);
  border-radius: 6px;
  font-size: 14px;
}

.filter-toggle {
  padding: 8px;
  border: 1px solid var(--color-border);
  border-radius: 6px;
  background: var(--color-surface);
  cursor: pointer;
}

.search-filters {
  padding: 16px;
  background: var(--color-surface);
  border-bottom: 1px solid var(--color-border);
}

.filter-group {
  margin-bottom: 16px;
}

.filter-group label {
  display: block;
  font-weight: 500;
  margin-bottom: 8px;
  color: var(--color-text);
}

.filter-options {
  display: flex;
  flex-wrap: wrap;
  gap: 12px;
}

.filter-options label {
  display: flex;
  align-items: center;
  gap: 4px;
  font-weight: normal;
  margin-bottom: 0;
}

.size-range {
  display: flex;
  align-items: center;
  gap: 8px;
}

.size-range input {
  flex: 1;
  padding: 6px 8px;
  border: 1px solid var(--color-border);
  border-radius: 4px;
}

.search-results {
  flex: 1;
  overflow-y: auto;
  padding: 8px;
}

.search-result-item {
  display: flex;
  align-items: center;
  gap: 12px;
  padding: 12px;
  border-radius: 6px;
  cursor: pointer;
  transition: background-color 0.2s;
}

.search-result-item:hover {
  background-color: var(--color-hover);
}

.result-icon {
  flex-shrink: 0;
  font-size: 18px;
  color: var(--color-primary);
}

.result-content {
  flex: 1;
  min-width: 0;
}

.result-title {
  font-weight: 500;
  color: var(--color-text);
  margin-bottom: 4px;
}

.result-path {
  font-size: 12px;
  color: var(--color-text-secondary);
  margin-bottom: 4px;
}

.result-preview {
  font-size: 12px;
  color: var(--color-text-secondary);
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.result-meta {
  flex-shrink: 0;
  text-align: right;
  font-size: 12px;
  color: var(--color-text-secondary);
}

.result-size,
.result-date {
  display: block;
  margin-bottom: 2px;
}
</style>
```

### 2. 响应式布局扩展

#### 布局模式定义
```typescript
// types/layout.ts
export interface LayoutMode {
  id: string
  name: string
  description: string
  breakpoints: Breakpoint[]
  panels: PanelConfig[]
}

export interface Breakpoint {
  name: string
  minWidth: number
  maxWidth?: number
}

export interface PanelConfig {
  id: string
  position: 'left' | 'right' | 'top' | 'bottom' | 'center'
  size: string | number
  collapsible: boolean
  resizable: boolean
  visible: boolean
}
```

#### 布局管理器
```typescript
// services/layout-manager.ts
class LayoutManager {
  private modes = new Map<string, LayoutMode>()
  private currentMode: LayoutMode | null = null
  private currentBreakpoint: Breakpoint | null = null

  register(mode: LayoutMode): void {
    this.modes.set(mode.id, mode)
  }

  setMode(modeId: string): void {
    const mode = this.modes.get(modeId)
    if (!mode) return

    this.currentMode = mode
    this.applyLayout()
  }

  private applyLayout(): void {
    if (!this.currentMode) return

    // 检测当前断点
    this.currentBreakpoint = this.detectBreakpoint()

    // 应用面板配置
    this.currentMode.panels.forEach(panel => {
      this.applyPanelConfig(panel)
    })
  }

  private detectBreakpoint(): Breakpoint | null {
    if (!this.currentMode) return null

    const width = window.innerWidth

    return this.currentMode.breakpoints.find(bp =>
      width >= bp.minWidth && (!bp.maxWidth || width <= bp.maxWidth)
    ) || null
  }

  private applyPanelConfig(config: PanelConfig): void {
    const element = document.querySelector(`[data-panel="${config.id}"]`)
    if (!element) return

    const htmlElement = element as HTMLElement

    // 应用尺寸
    if (typeof config.size === 'number') {
      htmlElement.style.flexBasis = `${config.size}px`
    } else {
      htmlElement.style.flexBasis = config.size
    }

    // 应用可见性
    htmlElement.style.display = config.visible ? 'flex' : 'none'

    // 应用可调整大小
    if (config.resizable) {
      htmlElement.classList.add('resizable')
    } else {
      htmlElement.classList.remove('resizable')
    }
  }
}

export const layoutManager = new LayoutManager()

// 注册内置布局模式
layoutManager.register({
  id: 'desktop',
  name: '桌面布局',
  description: '适合大屏幕的三栏布局',
  breakpoints: [
    { name: 'desktop', minWidth: 1024 }
  ],
  panels: [
    { id: 'sidebar', position: 'left', size: '288px', collapsible: true, resizable: true, visible: true },
    { id: 'editor', position: 'center', size: '1fr', collapsible: false, resizable: false, visible: true },
    { id: 'ai-panel', position: 'right', size: '384px', collapsible: true, resizable: true, visible: true }
  ]
})

layoutManager.register({
  id: 'tablet',
  name: '平板布局',
  description: '适合中等屏幕的两栏布局',
  breakpoints: [
    { name: 'tablet', minWidth: 768, maxWidth: 1023 }
  ],
  panels: [
    { id: 'sidebar', position: 'left', size: '320px', collapsible: true, resizable: false, visible: true },
    { id: 'editor', position: 'center', size: '1fr', collapsible: false, resizable: false, visible: true },
    { id: 'ai-panel', position: 'right', size: '0px', collapsible: true, resizable: false, visible: false }
  ]
})

layoutManager.register({
  id: 'mobile',
  name: '移动布局',
  description: '适合小屏幕的单栏布局',
  breakpoints: [
    { name: 'mobile', minWidth: 0, maxWidth: 767 }
  ],
  panels: [
    { id: 'sidebar', position: 'left', size: '0px', collapsible: true, resizable: false, visible: false },
    { id: 'editor', position: 'center', size: '100%', collapsible: false, resizable: false, visible: true },
    { id: 'ai-panel', position: 'right', size: '0px', collapsible: true, resizable: false, visible: false }
  ]
})
```

## 🔌 集成扩展

### 1. 外部工具集成

#### Git 集成
```typescript
// services/git-integration.ts
export class GitIntegration {
  private repoPath: string

  constructor(repoPath: string) {
    this.repoPath = repoPath
  }

  async getStatus(): Promise<GitStatus> {
    // 调用 Git API 或命令行工具
    const response = await this.executeGitCommand('status --porcelain')
    return this.parseGitStatus(response)
  }

  async commit(message: string, files?: string[]): Promise<void> {
    if (files) {
      await this.executeGitCommand(`add ${files.join(' ')}`)
    } else {
      await this.executeGitCommand('add .')
    }

    await this.executeGitCommand(`commit -m "${message}"`)
  }

  async createBranch(name: string): Promise<void> {
    await this.executeGitCommand(`checkout -b ${name}`)
  }

  async switchBranch(name: string): Promise<void> {
    await this.executeGitCommand(`checkout ${name}`)
  }

  private async executeGitCommand(command: string): Promise<string> {
    // 实现 Git 命令执行
    // 可以使用 Web API 或 Electron 的 child_process
    throw new Error('Git command execution not implemented')
  }

  private parseGitStatus(output: string): GitStatus {
    const files: GitFileStatus[] = []
    const lines = output.split('\n').filter(line => line.trim())

    for (const line of lines) {
      const status = line.substring(0, 2)
      const path = line.substring(3)

      files.push({
        path,
        status: this.parseFileStatus(status),
        staged: status[0] !== ' ',
        modified: status[1] !== ' '
      })
    }

    return { files }
  }

  private parseFileStatus(status: string): GitFileChangeType {
    switch (status[0]) {
      case 'A': return 'added'
      case 'M': return 'modified'
      case 'D': return 'deleted'
      case 'R': return 'renamed'
      case '?': return 'untracked'
      default: return 'unknown'
    }
  }
}

interface GitStatus {
  files: GitFileStatus[]
}

interface GitFileStatus {
  path: string
  status: GitFileChangeType
  staged: boolean
  modified: boolean
}

type GitFileChangeType = 'added' | 'modified' | 'deleted' | 'renamed' | 'untracked' | 'unknown'
```

#### Docker 集成
```typescript
// services/docker-integration.ts
export class DockerIntegration {
  async buildImage(dockerfile: string, tag: string): Promise<BuildResult> {
    const buildCommand = `docker build -t ${tag} -f ${dockerfile} .`
    
    try {
      const output = await this.executeCommand(buildCommand)
      return { success: true, output }
    } catch (error) {
      return { success: false, error: error.message, output: '' }
    }
  }

  async runContainer(image: string, options: ContainerOptions): Promise<RunResult> {
    let command = `docker run`
    
    if (options.detach) command += ' -d'
    if (options.ports) {
      options.ports.forEach(port => {
        command += ` -p ${port.host}:${port.container}`
      })
    }
    if (options.volumes) {
      options.volumes.forEach(volume => {
        command += ` -v ${volume.host}:${volume.container}`
      })
    }
    if (options.environment) {
      Object.entries(options.environment).forEach(([key, value]) => {
        command += ` -e ${key}=${value}`
      })
    }
    
    command += ` ${image}`
    
    try {
      const output = await this.executeCommand(command)
      return { success: true, containerId: this.extractContainerId(output) }
    } catch (error) {
      return { success: false, error: error.message }
    }
  }

  async getContainerLogs(containerId: string): Promise<string> {
    return await this.executeCommand(`docker logs ${containerId}`)
  }

  async stopContainer(containerId: string): Promise<void> {
    await this.executeCommand(`docker stop ${containerId}`)
  }

  private async executeCommand(command: string): Promise<string> {
    // 实现命令执行
    throw new Error('Command execution not implemented')
  }

  private extractContainerId(output: string): string {
    // 从 docker run 输出中提取容器ID
    return output.trim()
  }
}

interface ContainerOptions {
  detach?: boolean
  ports?: Array<{ host: number; container: number }>
  volumes?: Array<{ host: string; container: string }>
  environment?: Record<string, string>
}

interface BuildResult {
  success: boolean
  output: string
  error?: string
}

interface RunResult {
  success: boolean
  containerId?: string
  error?: string
}
```

### 2. API接口扩展

#### RESTful API 集成
```typescript
// services/api-client.ts
export class APIClient {
  private baseUrl: string
  private headers: Record<string, string>

  constructor(baseUrl: string, defaultHeaders: Record<string, string> = {}) {
    this.baseUrl = baseUrl
    this.headers = {
      'Content-Type': 'application/json',
      ...defaultHeaders
    }
  }

  async get<T>(endpoint: string, params?: Record<string, any>): Promise<T> {
    const url = new URL(endpoint, this.baseUrl)
    
    if (params) {
      Object.entries(params).forEach(([key, value]) => {
        url.searchParams.append(key, String(value))
      })
    }

    const response = await fetch(url.toString(), {
      method: 'GET',
      headers: this.headers
    })

    if (!response.ok) {
      throw new Error(`API request failed: ${response.statusText}`)
    }

    return await response.json()
  }

  async post<T>(endpoint: string, data: any): Promise<T> {
    const response = await fetch(new URL(endpoint, this.baseUrl).toString(), {
      method: 'POST',
      headers: this.headers,
      body: JSON.stringify(data)
    })

    if (!response.ok) {
      throw new Error(`API request failed: ${response.statusText}`)
    }

    return await response.json()
  }

  async put<T>(endpoint: string, data: any): Promise<T> {
    const response = await fetch(new URL(endpoint, this.baseUrl).toString(), {
      method: 'PUT',
      headers: this.headers,
      body: JSON.stringify(data)
    })

    if (!response.ok) {
      throw new Error(`API request failed: ${response.statusText}`)
    }

    return await response.json()
  }

  async delete<T>(endpoint: string): Promise<T> {
    const response = await fetch(new URL(endpoint, this.baseUrl).toString(), {
      method: 'DELETE',
      headers: this.headers
    })

    if (!response.ok) {
      throw new Error(`API request failed: ${response.statusText}`)
    }

    return await response.json()
  }

  setAuthToken(token: string): void {
    this.headers['Authorization'] = `Bearer ${token}`
  }

  removeAuthToken(): void {
    delete this.headers['Authorization']
  }
}

// 使用示例
const githubAPI = new APIClient('https://api.github.com')

// GitHub 集成
export class GitHubIntegration {
  private client: APIClient

  constructor(token?: string) {
    this.client = new APIClient('https://api.github.com')
    if (token) {
      this.client.setAuthToken(token)
    }
  }

  async getRepositories(): Promise<Repository[]> {
    return await this.client.get<Repository[]>('/user/repos')
  }

  async createRepository(data: CreateRepoData): Promise<Repository> {
    return await this.client.post<Repository>('/user/repos', data)
  }

  async uploadFile(repo: string, path: string, content: string, message: string): Promise<void> {
    const data = {
      message,
      content: btoa(content), // Base64 编码
      branch: 'main'
    }

    await this.client.put(`/repos/${repo}/contents/${path}`, data)
  }

  async createGist(files: Record<string, { content: string }>, description?: string): Promise<Gist> {
    const data = {
      description: description || 'Created from Readdy Editor',
      public: false,
      files
    }

    return await this.client.post<Gist>('/gists', data)
  }
}

interface Repository {
  id: number
  name: string
  full_name: string
  private: boolean
  html_url: string
}

interface CreateRepoData {
  name: string
  description?: string
  private?: boolean
  auto_init?: boolean
}

interface Gist {
  id: string
  html_url: string
  files: Record<string, any>
}
```

### 3. 数据导入导出扩展

#### 多格式导出器
```typescript
// services/export-manager.ts
export class ExportManager {
  private exporters = new Map<string, FileExporter>()

  register(exporter: FileExporter): void {
    this.exporters.set(exporter.format, exporter)
  }

  async export(content: string, format: string, options?: ExportOptions): Promise<ExportResult> {
    const exporter = this.exporters.get(format)
    if (!exporter) {
      throw new Error(`不支持的导出格式: ${format}`)
    }

    return await exporter.export(content, options)
  }

  getSupportedFormats(): string[] {
    return Array.from(this.exporters.keys())
  }
}

export interface FileExporter {
  format: string
  name: string
  description: string
  fileExtension: string
  
  export(content: string, options?: ExportOptions): Promise<ExportResult>
}

export interface ExportOptions {
  filename?: string
  metadata?: Record<string, any>
  [key: string]: any
}

export interface ExportResult {
  success: boolean
  data?: Blob | string
  filename?: string
  error?: string
}

// PDF 导出器
export class PDFExporter implements FileExporter {
  format = 'pdf'
  name = 'PDF'
  description = '导出为PDF文档'
  fileExtension = 'pdf'

  async export(content: string, options?: ExportOptions): Promise<ExportResult> {
    try {
      // 使用 jsPDF 或其他PDF库
      const { jsPDF } = await import('jspdf')
      const doc = new jsPDF()

      // 处理Markdown内容
      const html = this.markdownToHTML(content)
      
      // 添加内容到PDF
      doc.html(html, {
        callback: (doc) => {
          const pdfBlob = doc.output('blob')
          return {
            success: true,
            data: pdfBlob,
            filename: options?.filename || 'document.pdf'
          }
        }
      })

      return { success: true }
    } catch (error) {
      return {
        success: false,
        error: `PDF导出失败: ${error.message}`
      }
    }
  }

  private markdownToHTML(markdown: string): string {
    // 简单的Markdown转HTML
    return markdown
      .replace(/^# (.*$)/gim, '<h1>$1</h1>')
      .replace(/^## (.*$)/gim, '<h2>$1</h2>')
      .replace(/^### (.*$)/gim, '<h3>$1</h3>')
      .replace(/\*\*(.*)\*\*/gim, '<strong>$1</strong>')
      .replace(/\*(.*)\*/gim, '<em>$1</em>')
      .replace(/\n/gim, '<br>')
  }
}

// Word 导出器
export class WordExporter implements FileExporter {
  format = 'docx'
  name = 'Word文档'
  description = '导出为Microsoft Word文档'
  fileExtension = 'docx'

  async export(content: string, options?: ExportOptions): Promise<ExportResult> {
    try {
      // 使用 docx 库
      const { Document, Packer, Paragraph, TextRun } = await import('docx')

      const doc = new Document({
        sections: [{
          properties: {},
          children: this.parseMarkdownToDocx(content)
        }]
      })

      const buffer = await Packer.toBuffer(doc)
      const blob = new Blob([buffer], { 
        type: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document' 
      })

      return {
        success: true,
        data: blob,
        filename: options?.filename || 'document.docx'
      }
    } catch (error) {
      return {
        success: false,
        error: `Word导出失败: ${error.message}`
      }
    }
  }

  private parseMarkdownToDocx(markdown: string): any[] {
    // 解析Markdown并转换为docx格式
    const lines = markdown.split('\n')
    const paragraphs = []

    for (const line of lines) {
      if (line.startsWith('# ')) {
        paragraphs.push(new Paragraph({
          children: [new TextRun({ text: line.substring(2), bold: true, size: 32 })]
        }))
      } else if (line.startsWith('## ')) {
        paragraphs.push(new Paragraph({
          children: [new TextRun({ text: line.substring(3), bold: true, size: 28 })]
        }))
      } else {
        paragraphs.push(new Paragraph({
          children: [new TextRun(line)]
        }))
      }
    }

    return paragraphs
  }
}

// 初始化导出管理器
export const exportManager = new ExportManager()
exportManager.register(new PDFExporter())
exportManager.register(new WordExporter())
```

## 📚 扩展开发最佳实践

### 1. 模块化设计原则

```typescript
// 良好的扩展模块结构
export interface ExtensionModule {
  // 模块信息
  id: string
  name: string
  version: string
  description?: string
  
  // 依赖声明
  dependencies?: string[]
  optionalDependencies?: string[]
  
  // 生命周期钩子
  onInstall?(): Promise<void>
  onActivate?(): Promise<void>
  onDeactivate?(): Promise<void>
  onUninstall?(): Promise<void>
  
  // 功能提供
  provides?: string[]
  
  // 配置选项
  configuration?: ConfigurationSchema
}

interface ConfigurationSchema {
  properties: Record<string, ConfigProperty>
}

interface ConfigProperty {
  type: 'string' | 'number' | 'boolean' | 'object' | 'array'
  default?: any
  description?: string
  enum?: any[]
}
```

### 2. 错误处理和日志

```typescript
// services/logger.ts
export class Logger {
  private context: string

  constructor(context: string) {
    this.context = context
  }

  debug(message: string, data?: any): void {
    console.debug(`[${this.context}] ${message}`, data)
  }

  info(message: string, data?: any): void {
    console.info(`[${this.context}] ${message}`, data)
  }

  warn(message: string, data?: any): void {
    console.warn(`[${this.context}] ${message}`, data)
  }

  error(message: string, error?: Error, data?: any): void {
    console.error(`[${this.context}] ${message}`, error, data)
    
    // 发送到错误收集服务
    this.reportError(message, error, data)
  }

  private reportError(message: string, error?: Error, data?: any): void {
    // 实现错误上报逻辑
  }
}

// 在扩展中使用
export class MyExtension {
  private logger = new Logger('MyExtension')

  async someMethod(): Promise<void> {
    try {
      this.logger.info('开始执行操作')
      // 执行操作
      this.logger.info('操作完成')
    } catch (error) {
      this.logger.error('操作失败', error, { context: 'someMethod' })
      throw error
    }
  }
}
```

### 3. 测试指南

```typescript
// tests/extensions/my-extension.test.ts
import { describe, it, expect, beforeEach, afterEach } from 'vitest'
import { MyExtension } from '../../../src/extensions/my-extension'

describe('MyExtension', () => {
  let extension: MyExtension

  beforeEach(() => {
    extension = new MyExtension()
  })

  afterEach(() => {
    // 清理
  })

  it('should initialize correctly', () => {
    expect(extension.id).toBe('my-extension')
    expect(extension.name).toBe('My Extension')
  })

  it('should handle file processing', async () => {
    const testContent = '# Test Document'
    const result = await extension.processFile(testContent)
    
    expect(result.success).toBe(true)
    expect(result.data).toContain('Test Document')
  })

  it('should handle errors gracefully', async () => {
    const invalidContent = null
    
    await expect(extension.processFile(invalidContent))
      .rejects.toThrow('Invalid content')
  })
})
```

### 4. 性能优化建议

```typescript
// 使用懒加载
const LazyComponent = defineAsyncComponent(() => import('./HeavyComponent.vue'))

// 使用防抖处理频繁操作
import { debounce } from 'lodash-es'

const debouncedSearch = debounce(async (query: string) => {
  // 执行搜索
}, 300)

// 使用缓存减少重复计算
const cache = new Map<string, any>()

function expensiveOperation(input: string): any {
  if (cache.has(input)) {
    return cache.get(input)
  }

  const result = performCalculation(input)
  cache.set(input, result)
  return result
}

// 使用Web Workers处理重CPU任务
const worker = new Worker('./heavy-computation.worker.ts')

worker.postMessage({ data: largeDataSet })
worker.onmessage = (event) => {
  const result = event.data
  // 处理结果
}
```

## 🚀 扩展发布指南

### 1. 扩展打包

```bash
# 打包扩展
npm run build:extension

# 生成扩展包
npm run package:extension

# 验证扩展包
npm run validate:extension
```

### 2. 扩展市场

```typescript
// extension-manifest.json
{
  "id": "my-awesome-extension",
  "name": "My Awesome Extension",
  "version": "1.0.0",
  "description": "An awesome extension for Readdy Editor",
  "author": "Your Name",
  "license": "MIT",
  "homepage": "https://github.com/yourname/my-awesome-extension",
  "repository": {
    "type": "git",
    "url": "https://github.com/yourname/my-awesome-extension.git"
  },
  "categories": ["Editor", "AI", "Tools"],
  "keywords": ["markdown", "ai", "productivity"],
  "engines": {
    "readdy": ">=1.0.0"
  },
  "activationEvents": [
    "onFileType:markdown",
    "onCommand:my-extension.activate"
  ],
  "main": "./dist/extension.js",
  "contributes": {
    "commands": [...],
    "fileTypes": [...],
    "themes": [...],
    "languages": [...]
  }
}
```

---

**最后更新**: 2025-07-03  
**适用版本**: Readdy Editor v1.0.0+  
**维护者**: Claude (Anthropic)

这个扩展开发指南为开发者提供了完整的扩展开发框架和最佳实践，帮助快速构建高质量的编辑器扩展功能。